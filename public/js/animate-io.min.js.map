{"version":3,"sources":["node_modules/browser-pack/_prelude.js","animate-io.js","src/js/Main.js","src/js/modules/AnimationStateMachine.js","src/js/modules/Animations.js","src/js/modules/Constants.js","src/js/modules/Helpers.js","src/js/modules/Mutations.js","src/js/modules/Observer.js","src/js/modules/Render.js","src/js/modules/Settings.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","_Settings","_Observer","_Animations","window","AnimateIO","InitObservers","_settings","OverrideDefaultObserverSettings","InitAIObservers","Observe","ObserveElementsContinuous","ObserveOnce","ObserveElementsOnce","StopObservers","KillAllObservers","DestroyObservers","DestroyAnimateIO","RestartObservers","RestartAnimateIO","Animate","OverrideDefaultAnimationSettings","InitAnimations","AnimateEnd","KillAnimateInstance","AnimateRestart","RestartAnimateInstance","./modules/Animations","./modules/Observer","./modules/Settings","2","Object","defineProperty","value","ResetStateMachine","StopAnimationObserver","ObserveStateMachineObjects","InitiateAnimationObserver","UpdateStateMachine","InitAnimationStateMachine","StateMachine","_Constants","_Render","activeCount","elements","singleFrameElements","populateStateMachine","count","console","log","callback","setTimeout","ForceRenderLoop","SMOTemplate","id","domElement","ratio","repeat","keyframes","observerAttached","populateCounter","done","_elements","document","getElementsByTagName","filter","elem","entries","attributes","map","some","test","name","hasAttribute","SMO_ID_ATTR_NAME","forEach","Array","from","attr","setAttribute","entry","processKeyFrames","push","kf","frames","_props","trim","split","key","val","numbers","replace","unshift","_offset","parseInt","offset","absOffset","props","AnimationSettings","mode","offsetTop","innerHeight","sort","b","frameIndex","propList","_fillPropForFrame","frame","prototype","hasOwnProperty","AnimationObserver","IntersectionObserver","observer","target","aioPlId","getAttribute","stateMachineObject","intersected","intersectionRatio","unobserve","smoIndex","findIndex","splice","root","rootMargin","threshold","observe","disconnect","smo","removeAttribute","./Constants","./Render","./Settings","3","_AnimationStateMachine","_Helpers","_Mutations","AnimationsInitialized","error","QueryMedia","deactivateBelow","InitRenderer","trackMutations","AddNewElementsToStateMachine","gridHelper","DrawGrid","WatchBrowserResize","AddMutationListener","mutations","response","matches","remove","StopRenderLoop","ResetMutationObserver","./AnimationStateMachine","./Helpers","./Mutations","4","5","AttrToNum","GetAttrVal","defaultValue","attrval","num","Number","isNaN","gridContainer","createElement","h","documentElement","scrollHeight","div","className","innerHTML","appendChild","body","mediaQuery","query","matchMedia","ObserveResult","removeListener","handler","addListener","6","StopMutationObserver","RemoveMutationListener","mutationObserver","MutationObserver","subscribers","subscriber","childList","subtree","characterData","s","index","7","ResetAnimateIO","ObserverList","ObserveAIOElements","ObserverSettings","AddNewAIOElements","helperCounter","AIOElements","querySelectorAll","observableAttrName","delay","offsetVal","classes","aioType","intersectionsettings","entryTimeOut","classList","exitIntersectionClassName","add","enterIntersectionClassName","clearTimeout","ObserveElements","options","defaultOptions","in","out","Element","NodeList","isPrototypeOf","HTMLCollection","Settings","indexOf","8","RenderLoop","scrollTop","scrollTopPrev","doc","raf_id","useFps","fps","parseFloat","animationTimeoutUpdate","requestAnimationFrame","animationUpdate","forceRender","pageYOffset","clientTop","elemTop","curFrame","nxtFrame","frame1_top","frame2_top","isBefore","isAfter","requiredFrame","keys","prop","_interpolateString","setStyle","progress","interpolatedValue","_calcInterpolation","val1","val2","valueIndex","val1Length","interpolated","style","match","uprCs","toUpperCase","cancelAnimationFrame","9","DefaultObserverSettings","DefaultAnimationSettings"],"mappings":"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","file":"animate-io.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\nvar _Settings = require(\"./modules/Settings\");\n\nvar _Observer = require(\"./modules/Observer\");\n\nvar _Animations = require(\"./modules/Animations\");\n\n(window => {\n  let InitObservers = _settings => {\n    // override settings passed from initialization\n    (0, _Settings.OverrideDefaultObserverSettings)(_settings); // scan for observable elements, attach intersection observer to each\n\n    (0, _Observer.InitAIObservers)();\n  };\n\n  let Animate = _settings => {\n    // override settings passed from initialization\n    (0, _Settings.OverrideDefaultAnimationSettings)(_settings); // scan for animateable elements, build the state machine, init rendering\n\n    (0, _Animations.InitAnimations)();\n  };\n\n  window.AnimateIO = {\n    InitObservers: InitObservers,\n    Observe: _Observer.ObserveElementsContinuous,\n    ObserveOnce: _Observer.ObserveElementsOnce,\n    StopObservers: _Observer.KillAllObservers,\n    DestroyObservers: _Observer.DestroyAnimateIO,\n    RestartObservers: _Observer.RestartAnimateIO,\n    Animate: Animate,\n    AnimateEnd: _Animations.KillAnimateInstance,\n    AnimateRestart: _Animations.RestartAnimateInstance\n  };\n})(window);\n\n},{\"./modules/Animations\":3,\"./modules/Observer\":7,\"./modules/Settings\":9}],2:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResetStateMachine = exports.StopAnimationObserver = exports.ObserveStateMachineObjects = exports.InitiateAnimationObserver = exports.UpdateStateMachine = exports.InitAnimationStateMachine = exports.StateMachine = void 0;\n\nvar _Constants = require(\"./Constants\");\n\nvar _Render = require(\"./Render\");\n\nvar _Settings = require(\"./Settings\");\n\nconst StateMachine = {\n  activeCount: 0,\n  elements: [],\n  singleFrameElements: []\n};\nexports.StateMachine = StateMachine;\n\nconst InitAnimationStateMachine = () => {\n  // filter out data-aio-<int> elements and push them to the StateMachine so that we can track them later\n  populateStateMachine(count => {\n    console.log(`${count} animateable elements found`);\n  });\n};\n\nexports.InitAnimationStateMachine = InitAnimationStateMachine;\n\nconst UpdateStateMachine = (callback = null) => {\n  populateStateMachine(count => {\n    console.log(`${count} new animateable elements found`);\n    ObserveStateMachineObjects(); // Wait for observers to get attached to new elements\n\n    setTimeout(() => (0, _Render.ForceRenderLoop)(), 100);\n  });\n}; // State Machine Object Template\n\n\nexports.UpdateStateMachine = UpdateStateMachine;\nconst SMOTemplate = {\n  id: '',\n  domElement: null,\n  ratio: 0,\n  repeat: true,\n  keyframes: [],\n  observerAttached: false\n};\nlet populateCounter = 0; // use this counter to generate unique ids for elements\n\nconst populateStateMachine = done => {\n  let AllElements = document.getElementsByTagName(\"*\"); // Filter elements with the signature: data-aio-<int>\n  // Example: data-aio-1000, data-aio-0\n\n  let AIOElements = [...AllElements].filter(elem => {\n    let attributes = Object.entries(elem.attributes).map(a => a[1]);\n    return attributes.some(f => /^data-aio--?[0-9]+/g.test(f.name));\n  }); // remove elements which have already been added & tracked inside animation state machien list\n\n  let _elements = AIOElements.filter(elem => !elem.hasAttribute(_Constants.SMO_ID_ATTR_NAME));\n\n  _elements.forEach((elem, i) => {\n    let {\n      attributes\n    } = elem;\n    let keyframes = Array.from(attributes).filter(attr => /^data-aio--?[0-9]+/g.test(attr.name));\n    let id = `aio-pl-${++populateCounter}-${i}`;\n    elem.setAttribute(_Constants.SMO_ID_ATTR_NAME, id);\n    let entry = { ...SMOTemplate\n    };\n    entry.id = id;\n    entry.repeat = elem.hasAttribute('data-aio-repeat');\n    entry.domElement = elem;\n    entry.keyframes = processKeyFrames(keyframes, elem);\n    entry.observerAttached = false;\n\n    if (keyframes.length == 1) {\n      StateMachine.singleFrameElements.push(entry);\n    } else {\n      StateMachine.elements.push(entry);\n    }\n  });\n\n  done(_elements.length);\n};\n\nconst processKeyFrames = (kf, elem) => {\n  let frames = [];\n  kf.forEach((f, i) => {\n    let _props = {};\n    f.value.trim().split(\";\").forEach(p => {\n      if (p.length > 0) {\n        let key = p.split(\":\")[0].trim();\n        let val = p.split(\":\")[1].trim();\n        let numbers = []; //Now parse ANY number inside this string and create a format string.\n\n        val = val.replace(/[\\-+]?[\\d]*\\.?[\\d]+/g, n => {\n          numbers.push(+n);\n          return '{?}';\n        }); //Add the formatstring as first value.\n\n        numbers.unshift(val);\n        _props[key] = {\n          value: numbers\n        };\n      }\n    });\n\n    let _offset = parseInt(f.name.replace('data-aio-', ''));\n\n    frames.push({\n      offset: _offset,\n      absOffset: _offset,\n      props: _props\n    });\n    elem.setAttribute(`data-kf-${i}`, _offset);\n  }); //convert offset to absolute\n\n  if (_Settings.AnimationSettings.mode == \"relative\") {\n    frames.forEach((f, i) => {\n      let offset = elem.offsetTop + f.offset - window.innerHeight;\n      f.absOffset = offset;\n      elem.setAttribute(`data-kf-${i}`, offset);\n    });\n  }\n\n  frames.sort((a, b) => a.absOffset > b.absOffset ? 1 : b.absOffset > a.absOffset ? -1 : 0); // handle missing props between frames\n\n  let frameIndex = 0;\n  let propList = {}; //iterate from left to right\n\n  for (; frameIndex < frames.length; frameIndex++) {\n    _fillPropForFrame(frames[frameIndex], propList);\n  } //iterate from right to left\n\n\n  propList = {};\n  frameIndex--;\n\n  for (; frameIndex >= 0; frameIndex--) {\n    _fillPropForFrame(frames[frameIndex], propList);\n  }\n\n  return frames;\n};\n\nlet _fillPropForFrame = function (frame, propList) {\n  var key; //For each key frame iterate over all right hand properties and assign them,\n  //but only if the current key frame doesn't have the property by itself\n\n  for (key in propList) {\n    //The current frame misses this property, so assign it.\n    if (!Object.prototype.hasOwnProperty.call(frame.props, key)) {\n      frame.props[key] = propList[key];\n    }\n  } //Iterate over all props of the current frame and collect them\n\n\n  for (key in frame.props) {\n    propList[key] = frame.props[key];\n  }\n};\n\nlet AnimationObserver = null;\n\nconst InitiateAnimationObserver = () => {\n  let observerSettings = {\n    root: null,\n    rootMargin: '0px',\n    threshold: 0\n  }; // init observer\n\n  AnimationObserver = new IntersectionObserver((entries, observer) => {\n    //console.log(entries)\n    entries.forEach(entry => {\n      let elem = entry.target;\n      let aioPlId = elem.getAttribute(_Constants.SMO_ID_ATTR_NAME);\n      let stateMachineObject = StateMachine.elements.filter(o => o.id == aioPlId)[0];\n      let intersected = false;\n      let ratio = entry.intersectionRatio;\n      stateMachineObject.ratio = ratio;\n      elem.setAttribute('data-ratio', ratio);\n\n      if (ratio > 0) {\n        intersected = true;\n        StateMachine.activeCount++;\n      }\n\n      if (ratio == 0 && intersected) {\n        StateMachine.activeCount--;\n\n        if (!stateMachineObject.repeat) {\n          observer.unobserve(elem);\n          let smoIndex = StateMachine.elements.findIndex(o => o.id == aioPlId);\n          StateMachine.elements.splice(smoIndex, 1);\n        }\n      }\n    });\n  }, observerSettings);\n};\n\nexports.InitiateAnimationObserver = InitiateAnimationObserver;\n\nconst ObserveStateMachineObjects = () => {\n  if (StateMachine.elements.length > 0) {\n    let newStateMachineElements = StateMachine.elements.filter(elem => !elem.observerAttached);\n    newStateMachineElements.forEach(elem => {\n      AnimationObserver.observe(elem.domElement);\n      elem.observerAttached = true;\n    });\n  }\n};\n\nexports.ObserveStateMachineObjects = ObserveStateMachineObjects;\n\nconst StopAnimationObserver = () => {\n  AnimationObserver.disconnect();\n};\n\nexports.StopAnimationObserver = StopAnimationObserver;\n\nconst RemoveSMOAttributes = () => {\n  let StateMachineObjects = [...StateMachine.elements, ...StateMachine.singleFrameElements];\n  StateMachineObjects.forEach(smo => {\n    smo.domElement.removeAttribute(_Constants.SMO_ID_ATTR_NAME);\n  });\n};\n\nconst ResetStateMachine = () => {\n  RemoveSMOAttributes();\n  StateMachine.activeCount = 0;\n  StateMachine.elements = [];\n  StateMachine.singleFrameElements = [];\n};\n\nexports.ResetStateMachine = ResetStateMachine;\n\n},{\"./Constants\":4,\"./Render\":8,\"./Settings\":9}],3:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RestartAnimateInstance = exports.KillAnimateInstance = exports.InitAnimations = void 0;\n\nvar _AnimationStateMachine = require(\"./AnimationStateMachine\");\n\nvar _Helpers = require(\"./Helpers\");\n\nvar _Mutations = require(\"./Mutations\");\n\nvar _Render = require(\"./Render\");\n\nvar _Settings = require(\"./Settings\");\n\nlet AnimationsInitialized = false;\n\nconst InitAnimations = () => {\n  if (AnimationsInitialized) {\n    console.error('AnimateIO.Animate() already initialized. To start a new instance, please stop the current animations instance using:\\nAnimateIO.StopAnimations();');\n  } // Check if browser dimensions are correct\n\n\n  let canInitialize = (0, _Helpers.QueryMedia)(`(min-width: ${_Settings.AnimationSettings.deactivateBelow}px)`);\n\n  if (!canInitialize) {\n    console.log(`AnimateIO.Animate() can't initialize since the screen width is less than ${_Settings.AnimationSettings.deactivateBelow}`);\n    return;\n  } // Initiate animation observer\n\n\n  (0, _AnimationStateMachine.InitiateAnimationObserver)(); //scan for animateable elements, build the state machine\n\n  (0, _AnimationStateMachine.InitAnimationStateMachine)(); // attach an observer to all the elements added to the State Machine\n\n  (0, _AnimationStateMachine.ObserveStateMachineObjects)(); // init rendering for all the elements\n\n  (0, _Render.InitRenderer)(); // look for new animateable objects with the signature data-aio-<int>\n  // start looking for new elements after an arbitrary delay of 2 seconds\n\n  if (_Settings.AnimationSettings.trackMutations) {\n    setTimeout(() => AddNewElementsToStateMachine(), 2000);\n  } // show a helper grid and markers for where an animation will start and end\n\n\n  if (_Settings.AnimationSettings.gridHelper) {\n    setTimeout(() => (0, _Helpers.DrawGrid)(), 1000);\n  }\n\n  AnimationsInitialized = true; // Check for browser resolution changes    \n\n  WatchBrowserResize();\n};\n\nexports.InitAnimations = InitAnimations;\n\nconst AddNewElementsToStateMachine = () => {\n  (0, _Mutations.AddMutationListener)({\n    name: 'animations_listener',\n    callback: mutations => {\n      (0, _AnimationStateMachine.UpdateStateMachine)();\n    }\n  });\n};\n\nconst WatchBrowserResize = () => {\n  (0, _Helpers.QueryMedia)(`(min-width: ${_Settings.AnimationSettings.deactivateBelow}px)`, response => {\n    if (response.matches) {\n      // Start animations if not already initialized\n      if (!AnimationsInitialized) {\n        if (response.remove != null) {\n          response.remove();\n          console.log(`Restarting AnimateIO.Animate as browser width is >= ${_Settings.AnimationSettings.deactivateBelow}px`);\n          InitAnimations();\n        }\n      }\n    } else {\n      // stop the animations if browser window shrinks below defined width\n      if (AnimationsInitialized) {\n        console.log(`Stopping AnimateIO.Animate as browser width is < ${_Settings.AnimationSettings.deactivateBelow}px`);\n        KillAnimateInstance();\n      }\n    }\n  });\n};\n\nconst KillAnimateInstance = () => {\n  // stop rendering\n  (0, _Render.StopRenderLoop)(); // Stop animation intersection observer\n\n  (0, _AnimationStateMachine.StopAnimationObserver)(); // disconnect mutation observer\n\n  (0, _Mutations.ResetMutationObserver)(); // reset state machine & remove state machine id attribute\n\n  (0, _AnimationStateMachine.ResetStateMachine)();\n  AnimationsInitialized = false;\n};\n\nexports.KillAnimateInstance = KillAnimateInstance;\n\nconst RestartAnimateInstance = () => {\n  KillAnimateInstance();\n  InitAnimations();\n};\n\nexports.RestartAnimateInstance = RestartAnimateInstance;\n\n},{\"./AnimationStateMachine\":2,\"./Helpers\":5,\"./Mutations\":6,\"./Render\":8,\"./Settings\":9}],4:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SMO_ID_ATTR_NAME = void 0;\nconst SMO_ID_ATTR_NAME = 'data-aio-smo-id';\nexports.SMO_ID_ATTR_NAME = SMO_ID_ATTR_NAME;\n\n},{}],5:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryMedia = exports.DrawGrid = exports.AttrToNum = exports.GetAttrVal = void 0;\n\nconst GetAttrVal = (elem, attr, defaultValue) => {\n  let val = defaultValue;\n\n  if (elem.hasAttribute(attr)) {\n    let attrval = elem.getAttribute(attr);\n\n    if (attrval != null) {\n      val = attrval;\n    }\n  }\n\n  return val;\n};\n\nexports.GetAttrVal = GetAttrVal;\n\nconst AttrToNum = (elem, attr, defaultValue) => {\n  let val = GetAttrVal(elem, attr, defaultValue);\n  let num = parseInt(val);\n  return Number.isNaN(num) ? defaultValue : num;\n};\n\nexports.AttrToNum = AttrToNum;\n\nconst DrawGrid = () => {\n  let gridContainer = document.createElement('div');\n  gridContainer.id = \"aio-grid-container\";\n  let h = document.documentElement.scrollHeight;\n\n  for (let i = 0; i < h; i += 100) {\n    let div = document.createElement('div');\n    div.className = \"aio-row\";\n    div.innerHTML = `<div class=\"num\">${i}</div><div class=\"num\">${i}</div>`;\n    gridContainer.appendChild(div);\n  }\n\n  document.body.appendChild(gridContainer);\n};\n\nexports.DrawGrid = DrawGrid;\n\nconst QueryMedia = (mediaQuery, callback = null) => {\n  let query = window.matchMedia(mediaQuery);\n\n  if (callback == null) {\n    return query.matches;\n  } else {\n    callback({\n      matches: query.matches,\n      remove: null\n    });\n\n    let ObserveResult = matches => {\n      callback({\n        matches: matches,\n        // use removeListener to support legacy browsers like 11 \n        //remove: () => query.removeEventListener('change', handler)\n        remove: () => query.removeListener(handler)\n      });\n    };\n\n    let handler = e => {\n      ObserveResult(e.matches);\n    }; // use addListener to support legacy browsers like 11\n\n\n    query.addListener(handler); //query.addEventListener('change', handler);\n  }\n};\n\nexports.QueryMedia = QueryMedia;\n\n},{}],6:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResetMutationObserver = exports.StopMutationObserver = exports.RemoveMutationListener = exports.AddMutationListener = void 0;\nlet mutationObserver = null;\n\n(() => {\n  mutationObserver = new MutationObserver(mutations => {\n    subscribers.forEach(subscriber => {\n      subscriber.callback(mutations);\n    });\n  }); //https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit\n\n  mutationObserver.observe(document, {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: true\n  });\n})();\n\nlet subscribers = []; // {\n//     name: \"\",\n//     callback: method\n// };\n\nconst AddMutationListener = subscriber => {\n  // check if already subscribed\n  let alreadySubscribed = subscribers.some(s => s.name == subscriber.name);\n\n  if (!alreadySubscribed) {\n    subscribers.push(subscriber); // Let's say AnimateIO is initialized at T0 and finds zero elements\n    // Then we add a mutation listener after arbitrary delay of 1000ms\n    // It's definitely possible that some mutations might have taken place in this time\n    // And the elements added in this time didn't get registered\n    // To overcome this issue we will manually execute subscriber callback once\n\n    subscriber.callback();\n  }\n};\n\nexports.AddMutationListener = AddMutationListener;\n\nconst RemoveMutationListener = name => {\n  let index = subscribers.findIndex(s => s.name == name);\n\n  if (index > -1) {\n    subscribers.splice(index, 1);\n  }\n\n  if (subscribers.length == 0) {\n    StopMutationObserver();\n  }\n};\n\nexports.RemoveMutationListener = RemoveMutationListener;\n\nconst StopMutationObserver = () => {\n  mutationObserver.disconnect();\n};\n\nexports.StopMutationObserver = StopMutationObserver;\n\nconst ResetMutationObserver = () => {\n  StopMutationObserver();\n  subscribers = [];\n};\n\nexports.ResetMutationObserver = ResetMutationObserver;\n\n},{}],7:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RestartAnimateIO = exports.DestroyAnimateIO = exports.ResetAnimateIO = exports.KillAllObservers = exports.ObserveElementsContinuous = exports.ObserveElementsOnce = exports.InitAIObservers = void 0;\n\nvar _Settings = require(\"./Settings\");\n\nvar _Helpers = require(\"./Helpers\");\n\nvar _Mutations = require(\"./Mutations\");\n\nlet ObserverList = [];\n\nconst InitAIObservers = () => {\n  // Scan for all AIO Elements & create observer for all of them\n  // Multiple observers so we can individually disconnect any element that we want\n  ObserveAIOElements(); // look for new observable objects \n  // start looking for new elements after an arbitrary delay of 2 seconds\n\n  if (_Settings.ObserverSettings.trackMutations) {\n    setTimeout(() => AddNewAIOElements(), 2000);\n  }\n};\n\nexports.InitAIObservers = InitAIObservers;\n\nconst AddNewAIOElements = () => {\n  (0, _Mutations.AddMutationListener)({\n    name: 'observer_listener',\n    callback: mutations => {\n      // delay the observer so the animation can be visible a bit\n      setTimeout(() => ObserveAIOElements(), 10);\n    }\n  });\n};\n\nlet helperCounter = 0;\n\nconst ObserveAIOElements = () => {\n  let AIOElements = document.querySelectorAll(`[${_Settings.ObserverSettings.observableAttrName}]`);\n  let elements = Array.from(AIOElements).filter(elem => !elem.hasAttribute('data-aio-id'));\n  elements.forEach((elem, i) => {\n    elem.setAttribute('data-aio-id', `aio_auto_${++helperCounter}_${i}`);\n\n    let repeat = elem.hasAttribute('data-aio-repeat') || _Settings.ObserverSettings.repeat;\n\n    let delay = (0, _Helpers.AttrToNum)(elem, 'data-aio-delay', _Settings.ObserverSettings.delay);\n    let offsetTop = (0, _Helpers.GetAttrVal)(elem, 'data-aio-offset-top', _Settings.ObserverSettings.rootMargin.split(\" \")[0]);\n    let offsetRgt = (0, _Helpers.GetAttrVal)(elem, 'data-aio-offset-right', _Settings.ObserverSettings.rootMargin.split(\" \")[1]);\n    let offsetBtm = (0, _Helpers.GetAttrVal)(elem, 'data-aio-offset-bottom', _Settings.ObserverSettings.rootMargin.split(\" \")[2]);\n    let offsetLft = (0, _Helpers.GetAttrVal)(elem, 'data-aio-offset-left', _Settings.ObserverSettings.rootMargin.split(\" \")[3]);\n    let rootMargin = `${offsetTop} ${offsetRgt} ${offsetBtm} ${offsetLft}`;\n\n    if (elem.hasAttribute(\"data-aio-offset\")) {\n      let offsetVal = elem.getAttribute(\"data-aio-offset\");\n\n      if (offsetVal != null && offsetVal.length > 0) {\n        rootMargin = offsetVal;\n      }\n    }\n\n    let intersected = false;\n    let classes = [];\n    let aioType = elem.getAttribute(_Settings.ObserverSettings.observableAttrName);\n\n    if (aioType.length > 0) {\n      classes.push(`aio-${aioType}`);\n    }\n\n    let intersectionsettings = {\n      root: _Settings.ObserverSettings.root,\n      rootMargin: rootMargin,\n      threshold: _Settings.ObserverSettings.threshold\n    };\n    let observer = new IntersectionObserver((entries, observer) => {\n      entries.forEach(entry => {\n        let ratio = entry.intersectionRatio;\n        let entryTimeOut = 0;\n\n        if (ratio > 0) {\n          intersected = true;\n          entryTimeOut = setTimeout(() => {\n            entry.target.classList.remove(_Settings.ObserverSettings.exitIntersectionClassName);\n            entry.target.classList.add(_Settings.ObserverSettings.enterIntersectionClassName);\n            classes.forEach(c => {\n              entry.target.classList.add(c);\n            });\n          }, delay);\n        }\n\n        if (ratio == 0 && repeat) {\n          clearTimeout(entryTimeOut);\n          entry.target.classList.remove(_Settings.ObserverSettings.enterIntersectionClassName);\n          classes.forEach(c => {\n            entry.target.classList.remove(c);\n          });\n          entry.target.classList.add(_Settings.ObserverSettings.exitIntersectionClassName);\n        }\n\n        if (ratio == 0 && !repeat && intersected) {\n          observer.unobserve(elem);\n          observer.disconnect();\n        }\n      });\n    }, intersectionsettings);\n    observer.observe(elem);\n    ObserverList.push(observer);\n  });\n};\n\nconst ObserveElements = (target, options, callback, repeat) => {\n  let defaultOptions = {\n    root: null,\n    rootMargin: '0px',\n    threshold: 0,\n    ...options\n  };\n  let observer = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      callback(entry);\n      let ratio = entry.intersectionRatio;\n\n      if (ratio != 0) {\n        if (entry.in) entry.in();\n\n        if (!repeat) {\n          observer.unobserve(entry.target);\n          observer.disconnect();\n        }\n      } else {\n        if (entry.out) entry.out();\n      }\n    });\n  }, defaultOptions);\n\n  if (typeof target == \"string\" && target.trim().length > 0) {\n    document.querySelectorAll(target).forEach(elem => observer.observe(elem));\n  } else if (target instanceof Element) {\n    observer.observe(target);\n  } else if (NodeList.prototype.isPrototypeOf(target)) {\n    target.forEach(elem => observer.observe(elem));\n  } else if (HTMLCollection.prototype.isPrototypeOf(target)) {\n    [...target].forEach(elem => observer.observe(elem));\n  } else {\n    console.error(`Target element: \"${target}\" not found`);\n  }\n};\n\nconst ObserveElementsOnce = (target, options, callback) => {\n  ObserveElements(target, options, callback, false);\n};\n\nexports.ObserveElementsOnce = ObserveElementsOnce;\n\nconst ObserveElementsContinuous = (target, options, callback) => {\n  ObserveElements(target, options, callback, true);\n};\n\nexports.ObserveElementsContinuous = ObserveElementsContinuous;\n\nconst KillAllObservers = () => {\n  ObserverList.forEach(o => {\n    o.disconnect();\n  });\n  ObserverList = [];\n};\n\nexports.KillAllObservers = KillAllObservers;\n\nconst ResetAnimateIO = () => {\n  KillAllObservers();\n\n  let _elems = document.querySelectorAll(`[${_Settings.ObserverSettings.observableAttrName}]`);\n\n  _elems.forEach((elem, i) => {\n    elem.classList.remove(Settings.enterIntersectionClassName);\n    let aioType = elem.getAttribute(_Settings.ObserverSettings.observableAttrName);\n\n    if (aioType.length > 0) {\n      elem.classList.remove(`aio-${aioType}`);\n    }\n  });\n};\n\nexports.ResetAnimateIO = ResetAnimateIO;\n\nconst DestroyAnimateIO = () => {\n  ResetAnimateIO();\n\n  let _elems = document.querySelectorAll(`[${_Settings.ObserverSettings.observableAttrName}]`);\n\n  _elems.forEach((elem, i) => {\n    let {\n      attributes\n    } = elem;\n    Array.from(attributes).forEach(attr => {\n      if (attr.name.indexOf(_Settings.ObserverSettings.observableAttrName) > -1) {\n        elem.removeAttribute(attr.name);\n      }\n    });\n  });\n};\n\nexports.DestroyAnimateIO = DestroyAnimateIO;\n\nconst RestartAnimateIO = () => {\n  ResetAnimateIO();\n  ObserveAIOElements();\n};\n\nexports.RestartAnimateIO = RestartAnimateIO;\n\n},{\"./Helpers\":5,\"./Mutations\":6,\"./Settings\":9}],8:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForceRenderLoop = exports.StopRenderLoop = exports.RenderLoop = exports.InitRenderer = void 0;\n\nvar _AnimationStateMachine = require(\"./AnimationStateMachine\");\n\nvar _Settings = require(\"./Settings\");\n\nlet scrollTop = 0;\nlet scrollTopPrev = -1;\nlet doc = document.documentElement;\nlet raf_id = 0; // Request Animate Frame ID\n\nconst InitRenderer = () => {\n  let useFps = true;\n  let {\n    fps\n  } = _Settings.AnimationSettings;\n\n  if (fps != null) {\n    let num = parseFloat(fps);\n    useFps = !isNaN(num);\n  }\n\n  if (useFps) {\n    (function animationTimeoutUpdate() {\n      RenderLoop();\n      setTimeout(() => {\n        raf_id = requestAnimationFrame(animationTimeoutUpdate);\n      }, 1000 / fps);\n    })();\n  } else {\n    (function animationUpdate() {\n      RenderLoop();\n      raf_id = requestAnimationFrame(animationUpdate);\n    })();\n  }\n};\n\nexports.InitRenderer = InitRenderer;\nlet forceRender = false;\n\nconst RenderLoop = () => {\n  if (_AnimationStateMachine.StateMachine.activeCount == 0) return;\n  scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0); // Exit render loop if no scrolling happened in this frame\n  // Exception: Continue with the render loop if forceRender flag is true\n\n  if (scrollTop == scrollTopPrev && !forceRender) return;\n  scrollTopPrev = scrollTop;\n  document.body.setAttribute(\"data-scroll-top\", scrollTop);\n  forceRender = false;\n\n  let entries = _AnimationStateMachine.StateMachine.elements.filter(entry => entry.ratio > 0);\n\n  entries.forEach(entry => {\n    let frames = entry.keyframes;\n    let elem = entry.domElement;\n    let elemTop = elem.offsetTop; //convert offset to absolute\n\n    if (_Settings.AnimationSettings.mode == \"relative\") {\n      frames.forEach((f, i) => {\n        let offset = elemTop + f.offset - window.innerHeight;\n        f.absOffset = offset;\n        elem.setAttribute(`data-kf-${i}`, offset);\n      });\n    }\n\n    for (let i = 0; i < frames.length - 1; i++) {\n      let curFrame = frames[i];\n      let nxtFrame = frames[i + 1];\n      let frame1_top = curFrame.absOffset;\n      let frame2_top = nxtFrame.absOffset;\n      let isBefore = scrollTop < frame1_top;\n      let isAfter = scrollTop > frame2_top;\n\n      if (isBefore || isAfter) {\n        //console.log(isBefore, isAfter);\n        let requiredFrame = isBefore ? curFrame : nxtFrame;\n        Object.keys(requiredFrame.props).forEach((key, index) => {\n          let prop = requiredFrame.props[key];\n\n          let value = _interpolateString(prop.value);\n\n          setStyle(elem, key, value);\n        });\n        return;\n      }\n\n      let progress = (scrollTop - frame1_top) / (frame2_top - frame1_top);\n      Object.keys(curFrame.props).forEach(key => {\n        let interpolatedValue = _calcInterpolation(curFrame.props[key].value, nxtFrame.props[key].value, progress);\n\n        let value = _interpolateString(interpolatedValue);\n\n        setStyle(elem, key, value);\n      });\n    }\n  });\n};\n\nexports.RenderLoop = RenderLoop;\n\nlet _calcInterpolation = (val1, val2, progress) => {\n  var valueIndex;\n  var val1Length = val1.length; //They both need to have the same length\n\n  if (val1Length !== val2.length) {\n    throw 'Can\\'t interpolate between \"' + val1[0] + '\" and \"' + val2[0] + '\"';\n  } //Add the format string as first element.\n\n\n  var interpolated = [val1[0]];\n  valueIndex = 1;\n\n  for (; valueIndex < val1Length; valueIndex++) {\n    //That's the line where the two numbers are actually interpolated.\n    interpolated[valueIndex] = val1[valueIndex] + (val2[valueIndex] - val1[valueIndex]) * progress;\n  }\n\n  return interpolated;\n};\n\nlet _interpolateString = val => {\n  let i = 1;\n  return val[0].replace(/\\{\\?\\}/g, () => {\n    return val[i++];\n  });\n};\n\nlet setStyle = (elem, key, value) => {\n  let style = elem.style; // Extract \"-x\", \"-m\" from string \"abc-xyz-mno\" \n\n  let match = key.match(/-./g);\n\n  if (match != null) {\n    // convert font-size to fontSize\n    let uprCs = match[0].toUpperCase();\n    let prop = key.replace(match[0], uprCs).replace('-', '');\n    style[prop] = value;\n  } else {\n    style[key] = value;\n  }\n};\n\nconst StopRenderLoop = () => {\n  cancelAnimationFrame(raf_id);\n}; // Force rederloop when new elements are added to statemachine\n\n\nexports.StopRenderLoop = StopRenderLoop;\n\nconst ForceRenderLoop = () => {\n  forceRender = true;\n};\n\nexports.ForceRenderLoop = ForceRenderLoop;\n\n},{\"./AnimationStateMachine\":2,\"./Settings\":9}],9:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OverrideDefaultAnimationSettings = exports.AnimationSettings = exports.OverrideDefaultObserverSettings = exports.ObserverSettings = void 0;\nconst DefaultObserverSettings = {\n  delay: 0,\n  offset: 0,\n  mode: 'relative',\n  observableAttrName: \"data-aiobserve\",\n  enterIntersectionClassName: \"aio-enter\",\n  exitIntersectionClassName: \"aio-exit\",\n  repeat: false,\n  threshold: 0,\n  root: null,\n  rootMargin: '0px 0px 0px 0px',\n  threshold: 0,\n  trackMutations: true\n};\nlet ObserverSettings = null;\nexports.ObserverSettings = ObserverSettings;\n\nconst OverrideDefaultObserverSettings = _settings => {\n  exports.ObserverSettings = ObserverSettings = { ...DefaultObserverSettings,\n    ..._settings\n  };\n  return ObserverSettings;\n};\n\nexports.OverrideDefaultObserverSettings = OverrideDefaultObserverSettings;\nconst DefaultAnimationSettings = {\n  gridHelper: false,\n  trackMutations: true,\n  fps: null,\n  deactivateBelow: 1025\n};\nlet AnimationSettings = null;\nexports.AnimationSettings = AnimationSettings;\n\nconst OverrideDefaultAnimationSettings = _settings => {\n  exports.AnimationSettings = AnimationSettings = { ...DefaultAnimationSettings,\n    ..._settings\n  };\n  return AnimationSettings;\n};\n\nexports.OverrideDefaultAnimationSettings = OverrideDefaultAnimationSettings;\n\n},{}]},{},[1])\n\n","import { OverrideDefaultObserverSettings, OverrideDefaultAnimationSettings } from './modules/Settings';\r\nimport { ObserveElementsOnce, ObserveElementsContinuous, KillAllObservers, RestartAnimateIO, DestroyAnimateIO, InitAIObservers } from './modules/Observer';\r\nimport { InitAnimations, KillAnimateInstance, RestartAnimateInstance } from './modules/Animations';\r\n\r\n((window) => {\r\n    let InitObservers = (_settings) => {\r\n\r\n        // override settings passed from initialization\r\n        OverrideDefaultObserverSettings(_settings);\r\n\r\n        // scan for observable elements, attach intersection observer to each\r\n        InitAIObservers();\r\n    }\r\n\r\n    let Animate = (_settings) => {\r\n\r\n        // override settings passed from initialization\r\n        OverrideDefaultAnimationSettings(_settings);\r\n\r\n        // scan for animateable elements, build the state machine, init rendering\r\n        InitAnimations();\r\n    }\r\n\r\n    window.AnimateIO = {\r\n        InitObservers: InitObservers,\r\n        Observe: ObserveElementsContinuous,\r\n        ObserveOnce: ObserveElementsOnce,\r\n        StopObservers: KillAllObservers,\r\n        DestroyObservers: DestroyAnimateIO,\r\n        RestartObservers: RestartAnimateIO,\r\n        Animate: Animate,\r\n        AnimateEnd: KillAnimateInstance,\r\n        AnimateRestart: RestartAnimateInstance\r\n    };\r\n})(window);","import { SMO_ID_ATTR_NAME } from './Constants';\r\nimport { ForceRenderLoop } from './Render';\r\nimport { AnimationSettings } from './Settings';\r\n\r\nexport const StateMachine = {\r\n    activeCount: 0,\r\n    elements: [],\r\n    singleFrameElements: []\r\n}\r\n\r\nexport const InitAnimationStateMachine = () => {\r\n    // filter out data-aio-<int> elements and push them to the StateMachine so that we can track them later\r\n    populateStateMachine((count) => {\r\n        console.log(`${count} animateable elements found`);\r\n    });\r\n}\r\n\r\nexport const UpdateStateMachine = (callback = null) => {\r\n    populateStateMachine((count) => {\r\n        console.log(`${count} new animateable elements found`);\r\n        ObserveStateMachineObjects();\r\n\r\n        // Wait for observers to get attached to new elements\r\n        setTimeout(() => ForceRenderLoop(), 100);\r\n    });\r\n}\r\n\r\n// State Machine Object Template\r\nconst SMOTemplate = {\r\n    id: '',\r\n    domElement: null,\r\n    ratio: 0,\r\n    repeat: true,\r\n    keyframes: [],\r\n    observerAttached: false\r\n}\r\n\r\nlet populateCounter = 0; // use this counter to generate unique ids for elements\r\n\r\nconst populateStateMachine = (done) => {\r\n    let AllElements = document.getElementsByTagName(\"*\");\r\n\r\n    // Filter elements with the signature: data-aio-<int>\r\n    // Example: data-aio-1000, data-aio-0\r\n    let AIOElements = [...AllElements].filter(elem => {\r\n        let attributes = Object.entries(elem.attributes).map(a => a[1])\r\n        return attributes.some(f => (/^data-aio--?[0-9]+/g).test(f.name));\r\n    });\r\n\r\n    // remove elements which have already been added & tracked inside animation state machien list\r\n    let _elements = AIOElements.filter(elem => !elem.hasAttribute(SMO_ID_ATTR_NAME));\r\n\r\n    _elements.forEach((elem, i) => {\r\n        let { attributes } = elem;\r\n\r\n        let keyframes = Array.from(attributes).filter(attr => (/^data-aio--?[0-9]+/g).test(attr.name));\r\n\r\n        let id = `aio-pl-${++populateCounter}-${i}`;\r\n        elem.setAttribute(SMO_ID_ATTR_NAME, id);\r\n\r\n        let entry = { ...SMOTemplate };\r\n        entry.id = id;\r\n        entry.repeat = elem.hasAttribute('data-aio-repeat');\r\n        entry.domElement = elem;\r\n        entry.keyframes = processKeyFrames(keyframes, elem);\r\n        entry.observerAttached = false;\r\n\r\n        if (keyframes.length == 1) {\r\n            StateMachine.singleFrameElements.push(entry);\r\n        } else {\r\n            StateMachine.elements.push(entry);\r\n        }\r\n    });\r\n    \r\n    done(_elements.length);\r\n}\r\n\r\n\r\nconst processKeyFrames = (kf, elem) => {\r\n    let frames = [];\r\n    kf.forEach((f, i) => {\r\n        let _props = {}\r\n\r\n        f.value.trim().split(\";\").forEach(p => {\r\n            if (p.length > 0) {\r\n                let key = p.split(\":\")[0].trim();\r\n                let val = p.split(\":\")[1].trim();\r\n\r\n                let numbers = [];\r\n                //Now parse ANY number inside this string and create a format string.\r\n                val = val.replace(/[\\-+]?[\\d]*\\.?[\\d]+/g, (n) => {\r\n                    numbers.push(+n);\r\n                    return '{?}';\r\n                });\r\n\r\n                //Add the formatstring as first value.\r\n                numbers.unshift(val);\r\n\r\n                _props[key] = {\r\n                    value: numbers\r\n                }\r\n            }\r\n        });\r\n\r\n        let _offset = parseInt(f.name.replace('data-aio-', ''));\r\n        frames.push({\r\n            offset: _offset,\r\n            absOffset: _offset,\r\n            props: _props\r\n        })\r\n\r\n        elem.setAttribute(`data-kf-${i}`, _offset);\r\n    });\r\n\r\n    //convert offset to absolute\r\n    if (AnimationSettings.mode == \"relative\") {\r\n        frames.forEach((f, i) => {\r\n            let offset = elem.offsetTop + f.offset - window.innerHeight;\r\n            f.absOffset = offset;\r\n            elem.setAttribute(`data-kf-${i}`, offset);\r\n        })\r\n    }\r\n\r\n    frames.sort((a, b) => a.absOffset > b.absOffset ? 1 : b.absOffset > a.absOffset ? -1 : 0);\r\n\r\n    // handle missing props between frames\r\n    let frameIndex = 0;\r\n    let propList = {};\r\n\r\n    //iterate from left to right\r\n    for (; frameIndex < frames.length; frameIndex++) {\r\n        _fillPropForFrame(frames[frameIndex], propList);\r\n    }\r\n\r\n    //iterate from right to left\r\n    propList = {};\r\n    frameIndex--;\r\n    for (; frameIndex >= 0; frameIndex--) {\r\n        _fillPropForFrame(frames[frameIndex], propList);\r\n    }\r\n\r\n    return frames;\r\n}\r\n\r\n\r\nlet _fillPropForFrame = function (frame, propList) {\r\n    var key;\r\n\r\n    //For each key frame iterate over all right hand properties and assign them,\r\n    //but only if the current key frame doesn't have the property by itself\r\n    for (key in propList) {\r\n        //The current frame misses this property, so assign it.\r\n        if (!Object.prototype.hasOwnProperty.call(frame.props, key)) {\r\n            frame.props[key] = propList[key];\r\n        }\r\n    }\r\n\r\n    //Iterate over all props of the current frame and collect them\r\n    for (key in frame.props) {\r\n        propList[key] = frame.props[key];\r\n    }\r\n}\r\n\r\n\r\nlet AnimationObserver = null;\r\nexport const InitiateAnimationObserver = () => {\r\n    let observerSettings = { root: null, rootMargin: '0px', threshold: 0 }\r\n    // init observer\r\n    AnimationObserver = new IntersectionObserver((entries, observer) => {\r\n        //console.log(entries)\r\n        entries.forEach(entry => {\r\n            let elem = entry.target;\r\n            let aioPlId = elem.getAttribute(SMO_ID_ATTR_NAME);\r\n\r\n            let stateMachineObject = StateMachine.elements.filter(o => o.id == aioPlId)[0];\r\n\r\n            let intersected = false;\r\n            let ratio = entry.intersectionRatio;\r\n            stateMachineObject.ratio = ratio;\r\n            elem.setAttribute('data-ratio', ratio);\r\n\r\n            if (ratio > 0) {\r\n                intersected = true;\r\n                StateMachine.activeCount++;\r\n            }\r\n\r\n            if (ratio == 0 && intersected) {\r\n                StateMachine.activeCount--;\r\n\r\n                if (!stateMachineObject.repeat) {\r\n                    observer.unobserve(elem);\r\n\r\n                    let smoIndex = StateMachine.elements.findIndex(o => o.id == aioPlId);\r\n                    StateMachine.elements.splice(smoIndex, 1);\r\n                }\r\n            }\r\n        })\r\n    }, observerSettings);\r\n}\r\n\r\nexport const ObserveStateMachineObjects = () => {\r\n    if (StateMachine.elements.length > 0) {\r\n        let newStateMachineElements = StateMachine.elements.filter(elem => !elem.observerAttached);\r\n        newStateMachineElements.forEach(elem => {\r\n            AnimationObserver.observe(elem.domElement);\r\n            elem.observerAttached = true;\r\n        });\r\n    }\r\n}\r\n\r\nexport const StopAnimationObserver = () => {\r\n    AnimationObserver.disconnect();\r\n}\r\n\r\nconst RemoveSMOAttributes = () => {\r\n    let StateMachineObjects = [...StateMachine.elements, ...StateMachine.singleFrameElements];\r\n\r\n    StateMachineObjects.forEach(smo => {\r\n        smo.domElement.removeAttribute(SMO_ID_ATTR_NAME);\r\n    })\r\n}\r\n\r\nexport const ResetStateMachine = () => {\r\n    RemoveSMOAttributes();\r\n\r\n    StateMachine.activeCount = 0;\r\n    StateMachine.elements = [];\r\n    StateMachine.singleFrameElements = [];\r\n}\r\n\r\n","import { InitAnimationStateMachine, InitiateAnimationObserver, ObserveStateMachineObjects, ResetStateMachine, StopAnimationObserver, UpdateStateMachine } from './AnimationStateMachine';\r\nimport { DrawGrid, QueryMedia } from './Helpers';\r\nimport { AddMutationListener, ResetMutationObserver } from './Mutations';\r\nimport { InitRenderer, StopRenderLoop } from './Render';\r\nimport { AnimationSettings } from './Settings';\r\n\r\nlet AnimationsInitialized = false;\r\nexport const InitAnimations = () => {\r\n    if (AnimationsInitialized) {\r\n        console.error('AnimateIO.Animate() already initialized. To start a new instance, please stop the current animations instance using:\\nAnimateIO.StopAnimations();')\r\n    }\r\n\r\n    // Check if browser dimensions are correct\r\n    let canInitialize = QueryMedia(`(min-width: ${AnimationSettings.deactivateBelow}px)`);\r\n    if (!canInitialize) {\r\n        console.log(`AnimateIO.Animate() can't initialize since the screen width is less than ${AnimationSettings.deactivateBelow}`);\r\n        return;\r\n    }\r\n\r\n    // Initiate animation observer\r\n    InitiateAnimationObserver();\r\n\r\n    //scan for animateable elements, build the state machine\r\n    InitAnimationStateMachine();\r\n\r\n    // attach an observer to all the elements added to the State Machine\r\n    ObserveStateMachineObjects();\r\n\r\n    // init rendering for all the elements\r\n    InitRenderer();\r\n\r\n    // look for new animateable objects with the signature data-aio-<int>\r\n    // start looking for new elements after an arbitrary delay of 2 seconds\r\n    if (AnimationSettings.trackMutations) {\r\n        setTimeout(() => AddNewElementsToStateMachine(), 2000);\r\n    }\r\n\r\n    // show a helper grid and markers for where an animation will start and end\r\n    if (AnimationSettings.gridHelper) {\r\n        setTimeout(() => DrawGrid(), 1000);\r\n    }\r\n\r\n    AnimationsInitialized = true;\r\n\r\n    // Check for browser resolution changes    \r\n    WatchBrowserResize();\r\n}\r\n\r\n\r\nconst AddNewElementsToStateMachine = () => {\r\n    AddMutationListener({\r\n        name: 'animations_listener',\r\n        callback: (mutations) => {\r\n            UpdateStateMachine();\r\n        }\r\n    })\r\n}\r\n\r\n\r\nconst WatchBrowserResize = () => {\r\n    QueryMedia(`(min-width: ${AnimationSettings.deactivateBelow}px)`, (response) => {\r\n        \r\n        if(response.matches) {\r\n            // Start animations if not already initialized\r\n            if(!AnimationsInitialized) {\r\n                if (response.remove != null) {\r\n                    response.remove();\r\n                    console.log(`Restarting AnimateIO.Animate as browser width is >= ${AnimationSettings.deactivateBelow}px`);\r\n                    InitAnimations();\r\n                }\r\n            }            \r\n        } else {\r\n            // stop the animations if browser window shrinks below defined width\r\n            if(AnimationsInitialized) {\r\n                console.log(`Stopping AnimateIO.Animate as browser width is < ${AnimationSettings.deactivateBelow}px`);\r\n                KillAnimateInstance();\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport const KillAnimateInstance = () => {\r\n\r\n    // stop rendering\r\n    StopRenderLoop();\r\n\r\n    // Stop animation intersection observer\r\n    StopAnimationObserver();\r\n\r\n    // disconnect mutation observer\r\n    ResetMutationObserver();\r\n\r\n    // reset state machine & remove state machine id attribute\r\n    ResetStateMachine();\r\n\r\n    AnimationsInitialized = false;\r\n}\r\n\r\nexport const RestartAnimateInstance = () => {\r\n    KillAnimateInstance();\r\n    InitAnimations();\r\n}\r\n\r\n\r\n","export const SMO_ID_ATTR_NAME = 'data-aio-smo-id';","export const GetAttrVal = (elem, attr, defaultValue) => {\r\n    let val = defaultValue;\r\n    if (elem.hasAttribute(attr)) {\r\n        let attrval = elem.getAttribute(attr);\r\n        if (attrval != null) {\r\n            val = attrval;\r\n        }\r\n    }\r\n    return val;\r\n}\r\n\r\nexport const AttrToNum = (elem, attr, defaultValue) => {\r\n    let val = GetAttrVal(elem, attr, defaultValue);\r\n    let num = parseInt(val);\r\n    return Number.isNaN(num) ? defaultValue : num;\r\n}\r\n\r\nexport const DrawGrid = () => {\r\n    let gridContainer = document.createElement('div');\r\n    gridContainer.id = \"aio-grid-container\";\r\n\r\n    let h = document.documentElement.scrollHeight;\r\n    for (let i = 0; i < h; i += 100) {\r\n        let div = document.createElement('div');\r\n        div.className = \"aio-row\";\r\n        div.innerHTML = `<div class=\"num\">${i}</div><div class=\"num\">${i}</div>`;\r\n        gridContainer.appendChild(div);\r\n    }\r\n\r\n    document.body.appendChild(gridContainer);\r\n}\r\n\r\n\r\nexport const QueryMedia = (mediaQuery, callback = null) => {\r\n    let query = window.matchMedia(mediaQuery);\r\n\r\n    if (callback == null) {\r\n        return query.matches;\r\n    } else {\r\n        callback({ matches: query.matches, remove: null });\r\n\r\n\r\n\r\n        let ObserveResult = (matches) => {\r\n            callback({\r\n                matches: matches,\r\n                // use removeListener to support legacy browsers like 11 \r\n                //remove: () => query.removeEventListener('change', handler)\r\n                remove: () => query.removeListener(handler) \r\n            });\r\n        }\r\n\r\n        let handler = (e) => {\r\n            ObserveResult(e.matches)\r\n        }\r\n\r\n        // use addListener to support legacy browsers like 11\r\n        query.addListener(handler);\r\n        //query.addEventListener('change', handler);\r\n\r\n    }\r\n}","let mutationObserver = null;\r\n\r\n(() => {\r\n    mutationObserver = new MutationObserver(mutations => {\r\n        subscribers.forEach(subscriber => {\r\n            subscriber.callback(mutations);\r\n        })\r\n    });\r\n\r\n    //https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit\r\n    mutationObserver.observe(document, {\r\n        attributes: false,\r\n        childList: true,\r\n        subtree: true,\r\n        characterData: true\r\n    });\r\n})();\r\n\r\nlet subscribers = [];\r\n// {\r\n//     name: \"\",\r\n//     callback: method\r\n// };\r\n\r\nexport const AddMutationListener = (subscriber) => {\r\n\r\n    // check if already subscribed\r\n    let alreadySubscribed = subscribers.some(s => s.name == subscriber.name)\r\n\r\n    if (!alreadySubscribed) {\r\n        subscribers.push(subscriber);\r\n\r\n        // Let's say AnimateIO is initialized at T0 and finds zero elements\r\n        // Then we add a mutation listener after arbitrary delay of 1000ms\r\n        // It's definitely possible that some mutations might have taken place in this time\r\n        // And the elements added in this time didn't get registered\r\n        // To overcome this issue we will manually execute subscriber callback once\r\n        subscriber.callback();\r\n    }\r\n}\r\n\r\nexport const RemoveMutationListener = (name) => {\r\n    let index = subscribers.findIndex(s => s.name == name);\r\n    if(index > -1) {\r\n        subscribers.splice(index, 1);\r\n    }\r\n\r\n    if(subscribers.length == 0) {\r\n        StopMutationObserver();\r\n    }\r\n}\r\n\r\n\r\nexport const StopMutationObserver = () => {\r\n    mutationObserver.disconnect();\r\n}\r\n\r\nexport const ResetMutationObserver = () => {\r\n    StopMutationObserver();\r\n    subscribers = [];\r\n}","import { ObserverSettings } from './Settings';\r\nimport { AttrToNum, GetAttrVal } from './Helpers';\r\nimport { AddMutationListener } from './Mutations';\r\n\r\nlet ObserverList = [];\r\n\r\n\r\nexport const InitAIObservers = () => {\r\n\r\n    // Scan for all AIO Elements & create observer for all of them\r\n    // Multiple observers so we can individually disconnect any element that we want\r\n    ObserveAIOElements();\r\n\r\n    \r\n    // look for new observable objects \r\n    // start looking for new elements after an arbitrary delay of 2 seconds\r\n    if (ObserverSettings.trackMutations) {\r\n        setTimeout(() => AddNewAIOElements(), 2000);\r\n    }\r\n}\r\n\r\nconst AddNewAIOElements = () => {\r\n    AddMutationListener({\r\n        name: 'observer_listener',\r\n        callback: (mutations) => {\r\n            // delay the observer so the animation can be visible a bit\r\n            setTimeout(() => ObserveAIOElements(), 10);\r\n        }\r\n    })\r\n}\r\n\r\nlet helperCounter = 0;\r\n\r\nconst ObserveAIOElements = () => {\r\n\r\n    let AIOElements = document.querySelectorAll(`[${ObserverSettings.observableAttrName}]`);\r\n    let elements = Array.from(AIOElements).filter(elem => !elem.hasAttribute('data-aio-id'));\r\n\r\n    elements.forEach((elem, i) => {\r\n        elem.setAttribute('data-aio-id', `aio_auto_${++helperCounter}_${i}`);\r\n\r\n        let repeat = elem.hasAttribute('data-aio-repeat') || ObserverSettings.repeat;\r\n        let delay = AttrToNum(elem, 'data-aio-delay', ObserverSettings.delay);\r\n        let offsetTop = GetAttrVal(elem, 'data-aio-offset-top', ObserverSettings.rootMargin.split(\" \")[0]);\r\n        let offsetRgt = GetAttrVal(elem, 'data-aio-offset-right', ObserverSettings.rootMargin.split(\" \")[1]);\r\n        let offsetBtm = GetAttrVal(elem, 'data-aio-offset-bottom', ObserverSettings.rootMargin.split(\" \")[2]);\r\n        let offsetLft = GetAttrVal(elem, 'data-aio-offset-left', ObserverSettings.rootMargin.split(\" \")[3]);\r\n        let rootMargin = `${offsetTop} ${offsetRgt} ${offsetBtm} ${offsetLft}`;\r\n        if (elem.hasAttribute(\"data-aio-offset\")) {\r\n            let offsetVal = elem.getAttribute(\"data-aio-offset\");\r\n            if (offsetVal != null && offsetVal.length > 0) {\r\n                rootMargin = offsetVal;\r\n            }\r\n        }\r\n        let intersected = false;\r\n\r\n        let classes = [];\r\n        let aioType = elem.getAttribute(ObserverSettings.observableAttrName);\r\n        if (aioType.length > 0) {\r\n            classes.push(`aio-${aioType}`);\r\n        }\r\n\r\n        let intersectionsettings = {\r\n            root: ObserverSettings.root,\r\n            rootMargin: rootMargin,\r\n            threshold: ObserverSettings.threshold\r\n        }\r\n\r\n        let observer = new IntersectionObserver((entries, observer) => {\r\n            entries.forEach(entry => {\r\n                let ratio = entry.intersectionRatio;\r\n                let entryTimeOut = 0;\r\n\r\n                if (ratio > 0) {\r\n                    intersected = true;\r\n                    entryTimeOut = setTimeout(() => {\r\n                        entry.target.classList.remove(ObserverSettings.exitIntersectionClassName);\r\n                        entry.target.classList.add(ObserverSettings.enterIntersectionClassName);\r\n                        classes.forEach(c => {\r\n                            entry.target.classList.add(c);\r\n                        });\r\n                    }, delay);\r\n                }\r\n\r\n                if (ratio == 0 && repeat) {\r\n                    clearTimeout(entryTimeOut);\r\n                    entry.target.classList.remove(ObserverSettings.enterIntersectionClassName);\r\n                    classes.forEach(c => {\r\n                        entry.target.classList.remove(c);\r\n                    });\r\n                    entry.target.classList.add(ObserverSettings.exitIntersectionClassName);\r\n                }\r\n\r\n                if (ratio == 0 && !repeat && intersected) {\r\n                    observer.unobserve(elem);\r\n                    observer.disconnect();\r\n                }\r\n            })\r\n        }, intersectionsettings);\r\n\r\n        observer.observe(elem);\r\n        ObserverList.push(observer);\r\n    });\r\n}\r\n\r\nconst ObserveElements = (target, options, callback, repeat) => {\r\n    let defaultOptions = {\r\n        root: null,\r\n        rootMargin: '0px',\r\n        threshold: 0,\r\n        ...options\r\n    }\r\n    let observer = new IntersectionObserver((entries, observer) => {\r\n        entries.forEach(entry => {\r\n            callback(entry);\r\n\r\n            let ratio = entry.intersectionRatio;\r\n            if (ratio != 0) {\r\n                if (entry.in) entry.in();\r\n                if (!repeat) {\r\n                    observer.unobserve(entry.target);\r\n                    observer.disconnect();\r\n                }\r\n            } else {\r\n                if (entry.out) entry.out();\r\n            }\r\n        })\r\n    }, defaultOptions);\r\n\r\n    if (typeof target == \"string\" && target.trim().length > 0) {\r\n        document.querySelectorAll(target).forEach(elem => observer.observe(elem));\r\n    } else if (target instanceof Element) {\r\n        observer.observe(target);\r\n    } else if (NodeList.prototype.isPrototypeOf(target)) {\r\n        target.forEach(elem => observer.observe(elem));\r\n    } else if (HTMLCollection.prototype.isPrototypeOf(target)) {\r\n        [...target].forEach(elem => observer.observe(elem));\r\n    } else {\r\n        console.error(`Target element: \"${target}\" not found`);\r\n    }\r\n}\r\n\r\nexport const ObserveElementsOnce = (target, options, callback) => {\r\n    ObserveElements(target, options, callback, false);\r\n}\r\n\r\nexport const ObserveElementsContinuous = (target, options, callback) => {\r\n    ObserveElements(target, options, callback, true);\r\n}\r\n\r\n\r\n\r\nexport const KillAllObservers = () => {\r\n    ObserverList.forEach(o => {\r\n        o.disconnect();\r\n    });\r\n\r\n    ObserverList = [];\r\n}\r\n\r\nexport const ResetAnimateIO = () => {\r\n    KillAllObservers();\r\n    let _elems = document.querySelectorAll(`[${ObserverSettings.observableAttrName}]`);\r\n    _elems.forEach((elem, i) => {\r\n        elem.classList.remove(Settings.enterIntersectionClassName);\r\n\r\n        let aioType = elem.getAttribute(ObserverSettings.observableAttrName);\r\n        if (aioType.length > 0) {\r\n            elem.classList.remove(`aio-${aioType}`);\r\n        }\r\n    });\r\n}\r\n\r\nexport const DestroyAnimateIO = () => {\r\n    ResetAnimateIO();\r\n    let _elems = document.querySelectorAll(`[${ObserverSettings.observableAttrName}]`);\r\n    _elems.forEach((elem, i) => {\r\n        let { attributes } = elem;\r\n        Array.from(attributes).forEach(attr => {\r\n            if (attr.name.indexOf(ObserverSettings.observableAttrName) > -1) {\r\n                elem.removeAttribute(attr.name);\r\n            }\r\n        })\r\n    });\r\n}\r\n\r\nexport const RestartAnimateIO = () => {\r\n    ResetAnimateIO();\r\n    ObserveAIOElements();\r\n}\r\n","import { StateMachine } from './AnimationStateMachine'\r\nimport { AnimationSettings } from './Settings';\r\n\r\n\r\nlet scrollTop = 0;\r\nlet scrollTopPrev = -1;\r\nlet doc = document.documentElement;\r\nlet raf_id = 0; // Request Animate Frame ID\r\n\r\nexport const InitRenderer = () => {\r\n\r\n    let useFps = true;\r\n    let { fps } = AnimationSettings;\r\n\r\n    if (fps != null) {\r\n        let num = parseFloat(fps);\r\n        useFps = !isNaN(num);\r\n    }\r\n\r\n    if (useFps) {\r\n        (function animationTimeoutUpdate() {\r\n            RenderLoop();\r\n            setTimeout(() => {\r\n                raf_id = requestAnimationFrame(animationTimeoutUpdate);\r\n            }, 1000 / fps);\r\n        }());\r\n    } else {\r\n        (function animationUpdate() {\r\n            RenderLoop();\r\n            raf_id = requestAnimationFrame(animationUpdate);\r\n        }());\r\n    }\r\n}\r\n\r\nlet forceRender = false;\r\n\r\nexport const RenderLoop = () => {\r\n    if (StateMachine.activeCount == 0) return;\r\n\r\n    scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\r\n\r\n    // Exit render loop if no scrolling happened in this frame\r\n    // Exception: Continue with the render loop if forceRender flag is true\r\n    if (scrollTop == scrollTopPrev && !forceRender) return;\r\n    scrollTopPrev = scrollTop;\r\n    document.body.setAttribute(\"data-scroll-top\", scrollTop);\r\n    forceRender = false;\r\n\r\n    let entries = StateMachine.elements.filter(entry => entry.ratio > 0);\r\n\r\n    entries.forEach(entry => {\r\n        let frames = entry.keyframes;\r\n        let elem = entry.domElement;\r\n        let elemTop = elem.offsetTop;\r\n\r\n        //convert offset to absolute\r\n        if (AnimationSettings.mode == \"relative\") {\r\n            frames.forEach((f, i) => {\r\n                let offset = elemTop + f.offset - window.innerHeight;\r\n                f.absOffset = offset;\r\n                elem.setAttribute(`data-kf-${i}`, offset);\r\n            })\r\n        }\r\n\r\n        for (let i = 0; i < frames.length - 1; i++) {\r\n            let curFrame = frames[i];\r\n            let nxtFrame = frames[i + 1];\r\n\r\n            let frame1_top = curFrame.absOffset;\r\n            let frame2_top = nxtFrame.absOffset;\r\n\r\n            let isBefore = scrollTop < frame1_top;\r\n            let isAfter = scrollTop > frame2_top;\r\n\r\n            if (isBefore || isAfter) {\r\n                //console.log(isBefore, isAfter);\r\n                let requiredFrame = isBefore ? curFrame : nxtFrame;\r\n\r\n                Object.keys(requiredFrame.props).forEach((key, index) => {\r\n                    let prop = requiredFrame.props[key];\r\n                    let value = _interpolateString(prop.value);\r\n                    setStyle(elem, key, value);\r\n                })\r\n                return;\r\n            }\r\n\r\n            let progress = (scrollTop - frame1_top) / (frame2_top - frame1_top);\r\n\r\n            Object.keys(curFrame.props).forEach(key => {\r\n                let interpolatedValue = _calcInterpolation(curFrame.props[key].value, nxtFrame.props[key].value, progress);\r\n                let value = _interpolateString(interpolatedValue);\r\n                setStyle(elem, key, value);\r\n            })\r\n        }\r\n    });\r\n}\r\n\r\nlet _calcInterpolation = (val1, val2, progress) => {\r\n    var valueIndex;\r\n    var val1Length = val1.length;\r\n\r\n    //They both need to have the same length\r\n    if (val1Length !== val2.length) {\r\n        throw 'Can\\'t interpolate between \"' + val1[0] + '\" and \"' + val2[0] + '\"';\r\n    }\r\n\r\n    //Add the format string as first element.\r\n    var interpolated = [val1[0]];\r\n\r\n    valueIndex = 1;\r\n\r\n    for (; valueIndex < val1Length; valueIndex++) {\r\n        //That's the line where the two numbers are actually interpolated.\r\n        interpolated[valueIndex] = val1[valueIndex] + ((val2[valueIndex] - val1[valueIndex]) * progress);\r\n    }\r\n\r\n    return interpolated;\r\n};\r\n\r\nlet _interpolateString = (val) => {\r\n    let i = 1;\r\n    return val[0].replace(/\\{\\?\\}/g, () => {\r\n        return val[i++];\r\n    });\r\n};\r\n\r\nlet setStyle = (elem, key, value) => {\r\n    let style = elem.style;\r\n\r\n    // Extract \"-x\", \"-m\" from string \"abc-xyz-mno\" \r\n    let match = key.match(/-./g);\r\n    if (match != null) {\r\n        // convert font-size to fontSize\r\n        let uprCs = match[0].toUpperCase();\r\n        let prop = key.replace(match[0], uprCs).replace('-', '');\r\n        style[prop] = value\r\n    } else {\r\n        style[key] = value;\r\n    }\r\n}\r\n\r\n\r\nexport const StopRenderLoop = () => {\r\n    cancelAnimationFrame(raf_id);\r\n}\r\n\r\n// Force rederloop when new elements are added to statemachine\r\nexport const ForceRenderLoop = () => {\r\n    forceRender = true;\r\n}","const DefaultObserverSettings = {\r\n    delay: 0,\r\n    offset: 0,\r\n    mode: 'relative',\r\n    observableAttrName: \"data-aiobserve\",\r\n    enterIntersectionClassName: \"aio-enter\",\r\n    exitIntersectionClassName: \"aio-exit\",\r\n    repeat: false,\r\n    threshold: 0,\r\n    root: null,\r\n    rootMargin: '0px 0px 0px 0px',\r\n    threshold: 0,\r\n    trackMutations: true\r\n}\r\n\r\nexport let ObserverSettings = null;\r\n\r\nexport const OverrideDefaultObserverSettings = (_settings) => {\r\n    ObserverSettings = { ...DefaultObserverSettings, ..._settings };\r\n    return ObserverSettings;\r\n}\r\n\r\n\r\nconst DefaultAnimationSettings = {\r\n    gridHelper: false,\r\n    trackMutations: true,\r\n    fps: null,\r\n    deactivateBelow: 1025\r\n}\r\n\r\nexport let AnimationSettings = null;\r\n\r\nexport const OverrideDefaultAnimationSettings = (_settings) => {\r\n    AnimationSettings = { ...DefaultAnimationSettings, ..._settings };\r\n    return AnimationSettings;\r\n}"]}