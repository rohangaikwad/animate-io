{"version":3,"sources":["node_modules/browser-pack/_prelude.js","animate-io.js","src/js/Main.js","src/js/modules/AnimationManager.js","src/js/modules/AnimationStateMachine.js","src/js/modules/Constants.js","src/js/modules/Helpers.js","src/js/modules/Mutations.js","src/js/modules/ObserverManager.js","src/js/modules/Render.js","src/js/modules/Settings.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","_Settings","_ObserverManager","_AnimationManager","window","AnimateIO","InitObservers","_settings","OverrideDefaultObserverSettings","InitAIObservers","Observe","ObserveElementsContinuous","ObserveOnce","ObserveElementsOnce","StopObservers","KillAllObservers","DestroyObservers","DestroyAnimateIO","RestartObservers","RestartAnimateIO","Animate","OverrideDefaultAnimationSettings","InitAnimations","AnimateEnd","KillAnimateInstance","AnimateRestart","RestartAnimateInstance","./modules/AnimationManager","./modules/ObserverManager","./modules/Settings","2","Object","defineProperty","value","_AnimationStateMachine","_Helpers","_Mutations","_Render","AnimationsInitialized","console","error","QueryMedia","AnimationSettings","activeRange","InitiateAnimationObserver","InitAnimationStateMachine","ObserveStateMachineObjects","InitRenderer","trackMutations","setTimeout","AddNewElementsToStateMachine","mutationWatchDelay","gridHelper","DrawGrid","WatchBrowserResize","log","AddMutationListener","name","callback","mutations","UpdateStateMachine","response","matches","remove","StopRenderLoop","StopAnimationObserver","ResetMutationObserver","ResetStateMachine","./AnimationStateMachine","./Helpers","./Mutations","./Render","./Settings","3","StateMachine","_Constants","activeCount","elements","singleFrameElements","populateStateMachine","count","ForceRenderLoop","SMOTemplate","id","domElement","ratio","repeat","keyframes","observerAttached","populateCounter","done","_elements","document","getElementsByTagName","filter","elem","entries","attributes","map","some","test","hasAttribute","SMO_ID_ATTR_NAME","forEach","Array","from","attr","setAttribute","entry","mode","_mode","getAttribute","processKeyFrames","push","kf","elem_mode","frames","_props","trim","split","key","val","numbers","replace","unshift","_offset","parseInt","offset","absOffset","props","offsetTop","innerHeight","sort","b","frameIndex","propList","_fillPropForFrame","frame","prototype","hasOwnProperty","AnimationObserver","IntersectionObserver","observer","target","aioPlId","stateMachineObject","intersected","intersectionRatio","unobserve","smoIndex","findIndex","splice","root","rootMargin","threshold","observe","disconnect","smo","removeAttribute","./Constants","4","5","RemoveClasses","AddClasses","AttrToNum","GetAttrVal","defaultValue","attrval","num","Number","isNaN","gridContainer","createElement","h","documentElement","scrollHeight","div","className","innerHTML","appendChild","body","classList","_className","add","mediaQuery","query","matchMedia","ObserveResult","removeListener","handler","addListener","6","StopMutationObserver","RemoveMutationListener","mutationObserver","MutationObserver","subscribers","subscriber","childList","subtree","characterData","s","index","7","ResetAnimateIO","ObserverList","ObserveAIOElements","ObserverSettings","AddNewAIOElements","helperCounter","AIOElements","querySelectorAll","observableAttrName","delay","offsetVal","custom_entry_attrVal","entry_classlist","enterIntersectionClassName","aioType","_class","custom_exit_attrVal","exit_classlist","exitIntersectionClassName","attributesApplied","lazy_attr_list","lazy_attrVal","parsed_array","JSON","parse","isArray","elementToObserve","refElems","intersectionsettings","Observer","_observer","entryTimeOut","keys","clearTimeout","NodeList","isPrototypeOf","_elem","ObserveElements","options","defaultOptions","in","out","Element","HTMLCollection","Settings","indexOf","8","RenderLoop","scrollTop","scrollTopPrev","doc","raf_id","useFps","fps","parseFloat","animationTimeoutUpdate","requestAnimationFrame","animationUpdate","forceRender","pageYOffset","clientTop","smObject","elemTop","curFrame","nxtFrame","frame1_top","frame2_top","isBefore","isAfter","requiredFrame","prop","_interpolateString","setStyle","progress","interpolatedValue","_calcInterpolation","val1","val2","valueIndex","val1Length","interpolated","style","match","uprCs","toUpperCase","cancelAnimationFrame","9","DefaultObserverSettings","DefaultAnimationSettings"],"mappings":"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","file":"animate-io.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\nvar _Settings = require(\"./modules/Settings\");\n\nvar _ObserverManager = require(\"./modules/ObserverManager\");\n\nvar _AnimationManager = require(\"./modules/AnimationManager\");\n\n(window => {\n  let InitObservers = _settings => {\n    // override settings passed from initialization\n    (0, _Settings.OverrideDefaultObserverSettings)(_settings); // scan for observable elements, attach intersection observer to each\n\n    (0, _ObserverManager.InitAIObservers)();\n  };\n\n  let Animate = _settings => {\n    // override settings passed from initialization\n    (0, _Settings.OverrideDefaultAnimationSettings)(_settings); // scan for animateable elements, build the state machine, init rendering\n\n    (0, _AnimationManager.InitAnimations)();\n  };\n\n  window.AnimateIO = {\n    InitObservers: InitObservers,\n    Observe: _ObserverManager.ObserveElementsContinuous,\n    ObserveOnce: _ObserverManager.ObserveElementsOnce,\n    StopObservers: _ObserverManager.KillAllObservers,\n    DestroyObservers: _ObserverManager.DestroyAnimateIO,\n    RestartObservers: _ObserverManager.RestartAnimateIO,\n    Animate: Animate,\n    AnimateEnd: _AnimationManager.KillAnimateInstance,\n    AnimateRestart: _AnimationManager.RestartAnimateInstance\n  };\n})(window);\n\n},{\"./modules/AnimationManager\":2,\"./modules/ObserverManager\":7,\"./modules/Settings\":9}],2:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RestartAnimateInstance = exports.KillAnimateInstance = exports.InitAnimations = void 0;\n\nvar _AnimationStateMachine = require(\"./AnimationStateMachine\");\n\nvar _Helpers = require(\"./Helpers\");\n\nvar _Mutations = require(\"./Mutations\");\n\nvar _Render = require(\"./Render\");\n\nvar _Settings = require(\"./Settings\");\n\nlet AnimationsInitialized = false;\n\nconst InitAnimations = () => {\n  if (AnimationsInitialized) {\n    console.error('AnimateIO.Animate() already initialized. To start a new instance, please stop the current animations instance using:\\nAnimateIO.StopAnimations();');\n  } // Check if browser dimensions are correct\n\n\n  let canInitialize = (0, _Helpers.QueryMedia)(_Settings.AnimationSettings.activeRange);\n\n  if (!canInitialize) {\n    console.log(`AnimateIO.Animate() can't initialize since the screen width is outside the range: ${_Settings.AnimationSettings.activeRange}`);\n    return;\n  } // Initiate animation observer\n\n\n  (0, _AnimationStateMachine.InitiateAnimationObserver)(); //scan for animateable elements, build the state machine\n\n  (0, _AnimationStateMachine.InitAnimationStateMachine)(); // attach an observer to all the elements added to the State Machine\n\n  (0, _AnimationStateMachine.ObserveStateMachineObjects)(); // init rendering for all the elements\n\n  (0, _Render.InitRenderer)(); // look for new animateable objects with the signature data-aio-<int>\n  // start looking for new elements after an arbitrary delay of 2 seconds\n\n  if (_Settings.AnimationSettings.trackMutations) {\n    setTimeout(() => AddNewElementsToStateMachine(), _Settings.AnimationSettings.mutationWatchDelay);\n  } // show a helper grid and markers for where an animation will start and end\n\n\n  if (_Settings.AnimationSettings.gridHelper) {\n    setTimeout(() => (0, _Helpers.DrawGrid)(), 1000);\n  }\n\n  AnimationsInitialized = true; // Check for browser resolution changes    \n\n  WatchBrowserResize();\n};\n\nexports.InitAnimations = InitAnimations;\n\nconst AddNewElementsToStateMachine = () => {\n  (0, _Mutations.AddMutationListener)({\n    name: 'animations_listener',\n    callback: mutations => {\n      (0, _AnimationStateMachine.UpdateStateMachine)();\n    }\n  });\n};\n\nconst WatchBrowserResize = () => {\n  (0, _Helpers.QueryMedia)(_Settings.AnimationSettings.activeRange, response => {\n    if (response.matches) {\n      // Start animations if not already initialized\n      if (!AnimationsInitialized) {\n        if (response.remove != null) {\n          response.remove();\n          console.log(`Restarting AnimateIO.Animate as browser width is inside the acceptable range: ${_Settings.AnimationSettings.activeRange}px`);\n          InitAnimations();\n        }\n      }\n    } else {\n      // stop the animations if browser window shrinks below defined width\n      if (AnimationsInitialized) {\n        console.log(`Stopping AnimateIO.Animate as browser width is outside the range: ${_Settings.AnimationSettings.activeRange}`);\n        KillAnimateInstance();\n      }\n    }\n  });\n};\n\nconst KillAnimateInstance = () => {\n  // stop rendering\n  (0, _Render.StopRenderLoop)(); // Stop animation intersection observer\n\n  (0, _AnimationStateMachine.StopAnimationObserver)(); // disconnect mutation observer\n\n  (0, _Mutations.ResetMutationObserver)(); // reset state machine & remove state machine id attribute\n\n  (0, _AnimationStateMachine.ResetStateMachine)();\n  AnimationsInitialized = false;\n};\n\nexports.KillAnimateInstance = KillAnimateInstance;\n\nconst RestartAnimateInstance = () => {\n  KillAnimateInstance();\n  InitAnimations();\n};\n\nexports.RestartAnimateInstance = RestartAnimateInstance;\n\n},{\"./AnimationStateMachine\":3,\"./Helpers\":5,\"./Mutations\":6,\"./Render\":8,\"./Settings\":9}],3:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResetStateMachine = exports.StopAnimationObserver = exports.ObserveStateMachineObjects = exports.InitiateAnimationObserver = exports.UpdateStateMachine = exports.InitAnimationStateMachine = exports.StateMachine = void 0;\n\nvar _Constants = require(\"./Constants\");\n\nvar _Render = require(\"./Render\");\n\nvar _Settings = require(\"./Settings\");\n\nconst StateMachine = {\n  activeCount: 0,\n  elements: [],\n  singleFrameElements: []\n};\nexports.StateMachine = StateMachine;\n\nconst InitAnimationStateMachine = () => {\n  // filter out data-aio-<int> elements and push them to the StateMachine so that we can track them later\n  populateStateMachine(count => {\n    console.log(`${count} animateable elements found`);\n  });\n};\n\nexports.InitAnimationStateMachine = InitAnimationStateMachine;\n\nconst UpdateStateMachine = (callback = null) => {\n  populateStateMachine(count => {\n    console.log(`${count} new animateable elements found`);\n    ObserveStateMachineObjects(); // Wait for observers to get attached to new elements\n\n    setTimeout(() => (0, _Render.ForceRenderLoop)(), 100);\n  });\n}; // State Machine Object Template\n\n\nexports.UpdateStateMachine = UpdateStateMachine;\nconst SMOTemplate = {\n  id: '',\n  domElement: null,\n  ratio: 0,\n  repeat: true,\n  keyframes: [],\n  observerAttached: false\n};\nlet populateCounter = 0; // use this counter to generate unique ids for elements\n\nconst populateStateMachine = done => {\n  let AllElements = document.getElementsByTagName(\"*\"); // Filter elements with the signature: data-aio-<int>\n  // Example: data-aio-1000, data-aio-0\n\n  let AIOElements = [...AllElements].filter(elem => {\n    let attributes = Object.entries(elem.attributes).map(a => a[1]);\n    return attributes.some(f => /^data-aio--?[0-9]+/g.test(f.name));\n  }); // remove elements which have already been added & tracked inside animation state machien list\n\n  let _elements = AIOElements.filter(elem => !elem.hasAttribute(_Constants.SMO_ID_ATTR_NAME));\n\n  _elements.forEach((elem, i) => {\n    let {\n      attributes\n    } = elem;\n    let keyframes = Array.from(attributes).filter(attr => /^data-aio--?[0-9]+/g.test(attr.name));\n    let id = `aio-pl-${++populateCounter}-${i}`;\n    elem.setAttribute(_Constants.SMO_ID_ATTR_NAME, id);\n    let entry = { ...SMOTemplate\n    };\n    let mode = _Settings.AnimationSettings.mode;\n\n    if (elem.hasAttribute('data-aio-mode')) {\n      let _mode = elem.getAttribute('data-aio-mode');\n\n      if (_mode.length > 0) mode = _mode;\n    }\n\n    entry.id = id;\n    entry.mode = mode;\n    entry.repeat = elem.hasAttribute('data-aio-repeat');\n    entry.domElement = elem;\n    entry.keyframes = processKeyFrames(keyframes, elem, mode);\n    entry.observerAttached = false;\n\n    if (keyframes.length == 1) {\n      StateMachine.singleFrameElements.push(entry);\n    } else {\n      StateMachine.elements.push(entry);\n    }\n  });\n\n  done(_elements.length);\n};\n\nconst processKeyFrames = (kf, elem, elem_mode) => {\n  let frames = [];\n  kf.forEach((f, i) => {\n    let _props = {};\n    f.value.trim().split(\";\").forEach(p => {\n      if (p.length > 0) {\n        let key = p.split(\":\")[0].trim();\n        let val = p.split(\":\")[1].trim();\n        let numbers = []; //Now parse ANY number inside this string and create a format string.\n\n        val = val.replace(/[\\-+]?[\\d]*\\.?[\\d]+/g, n => {\n          numbers.push(+n);\n          return '{?}';\n        }); //Add the formatstring as first value.\n\n        numbers.unshift(val);\n        _props[key] = {\n          value: numbers\n        };\n      }\n    });\n\n    let _offset = parseInt(f.name.replace('data-aio-', ''));\n\n    frames.push({\n      offset: _offset,\n      absOffset: _offset,\n      props: _props\n    });\n    elem.setAttribute(`data-kf-${i}`, _offset);\n  }); //convert offset to absolute\n\n  if (elem_mode == \"relative\") {\n    frames.forEach((f, i) => {\n      let offset = elem.offsetTop + f.offset - window.innerHeight;\n      f.absOffset = offset;\n      elem.setAttribute(`data-kf-${i}`, offset);\n    });\n  }\n\n  frames.sort((a, b) => a.absOffset > b.absOffset ? 1 : b.absOffset > a.absOffset ? -1 : 0); // handle missing props between frames\n\n  let frameIndex = 0;\n  let propList = {}; //iterate from left to right\n\n  for (; frameIndex < frames.length; frameIndex++) {\n    _fillPropForFrame(frames[frameIndex], propList);\n  } //iterate from right to left\n\n\n  propList = {};\n  frameIndex--;\n\n  for (; frameIndex >= 0; frameIndex--) {\n    _fillPropForFrame(frames[frameIndex], propList);\n  }\n\n  return frames;\n};\n\nlet _fillPropForFrame = function (frame, propList) {\n  var key; //For each key frame iterate over all right hand properties and assign them,\n  //but only if the current key frame doesn't have the property by itself\n\n  for (key in propList) {\n    //The current frame misses this property, so assign it.\n    if (!Object.prototype.hasOwnProperty.call(frame.props, key)) {\n      frame.props[key] = propList[key];\n    }\n  } //Iterate over all props of the current frame and collect them\n\n\n  for (key in frame.props) {\n    propList[key] = frame.props[key];\n  }\n};\n\nlet AnimationObserver = null;\n\nconst InitiateAnimationObserver = () => {\n  let observerSettings = {\n    root: null,\n    rootMargin: '0px',\n    threshold: 0\n  }; // init observer\n\n  AnimationObserver = new IntersectionObserver((entries, observer) => {\n    //console.log(entries)\n    entries.forEach(entry => {\n      let elem = entry.target;\n      let aioPlId = elem.getAttribute(_Constants.SMO_ID_ATTR_NAME);\n      let stateMachineObject = StateMachine.elements.filter(o => o.id == aioPlId)[0];\n      let intersected = false;\n      let ratio = entry.intersectionRatio;\n      stateMachineObject.ratio = ratio;\n      elem.setAttribute('data-ratio', ratio);\n\n      if (ratio > 0) {\n        intersected = true;\n        StateMachine.activeCount++;\n      }\n\n      if (ratio == 0 && intersected) {\n        StateMachine.activeCount--;\n\n        if (!stateMachineObject.repeat) {\n          observer.unobserve(elem);\n          let smoIndex = StateMachine.elements.findIndex(o => o.id == aioPlId);\n          StateMachine.elements.splice(smoIndex, 1);\n        }\n      }\n    });\n  }, observerSettings);\n};\n\nexports.InitiateAnimationObserver = InitiateAnimationObserver;\n\nconst ObserveStateMachineObjects = () => {\n  if (StateMachine.elements.length > 0) {\n    let newStateMachineElements = StateMachine.elements.filter(elem => !elem.observerAttached);\n    newStateMachineElements.forEach(elem => {\n      AnimationObserver.observe(elem.domElement);\n      elem.observerAttached = true;\n    });\n  }\n};\n\nexports.ObserveStateMachineObjects = ObserveStateMachineObjects;\n\nconst StopAnimationObserver = () => {\n  AnimationObserver.disconnect();\n};\n\nexports.StopAnimationObserver = StopAnimationObserver;\n\nconst RemoveSMOAttributes = () => {\n  let StateMachineObjects = [...StateMachine.elements, ...StateMachine.singleFrameElements];\n  StateMachineObjects.forEach(smo => {\n    smo.domElement.removeAttribute(_Constants.SMO_ID_ATTR_NAME);\n  });\n};\n\nconst ResetStateMachine = () => {\n  RemoveSMOAttributes();\n  StateMachine.activeCount = 0;\n  StateMachine.elements = [];\n  StateMachine.singleFrameElements = [];\n};\n\nexports.ResetStateMachine = ResetStateMachine;\n\n},{\"./Constants\":4,\"./Render\":8,\"./Settings\":9}],4:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SMO_ID_ATTR_NAME = void 0;\nconst SMO_ID_ATTR_NAME = 'data-aio-smo-id';\nexports.SMO_ID_ATTR_NAME = SMO_ID_ATTR_NAME;\n\n},{}],5:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryMedia = exports.RemoveClasses = exports.AddClasses = exports.DrawGrid = exports.AttrToNum = exports.GetAttrVal = void 0;\n\nconst GetAttrVal = (elem, attr, defaultValue) => {\n  let val = defaultValue;\n\n  if (elem.hasAttribute(attr)) {\n    let attrval = elem.getAttribute(attr);\n\n    if (attrval != null) {\n      val = attrval;\n    }\n  }\n\n  return val;\n};\n\nexports.GetAttrVal = GetAttrVal;\n\nconst AttrToNum = (elem, attr, defaultValue) => {\n  let val = GetAttrVal(elem, attr, defaultValue);\n  let num = parseInt(val);\n  return Number.isNaN(num) ? defaultValue : num;\n};\n\nexports.AttrToNum = AttrToNum;\n\nconst DrawGrid = () => {\n  let gridContainer = document.createElement('div');\n  gridContainer.id = \"aio-grid-container\";\n  let h = document.documentElement.scrollHeight;\n\n  for (let i = 0; i < h; i += 100) {\n    let div = document.createElement('div');\n    div.className = \"aio-row\";\n    div.innerHTML = `<div class=\"num\">${i}</div><div class=\"num\">${i}</div>`;\n    gridContainer.appendChild(div);\n  }\n\n  document.body.appendChild(gridContainer);\n};\n\nexports.DrawGrid = DrawGrid;\n\nconst AddClasses = (elem, classList) => {\n  classList.forEach(_className => {\n    elem.classList.add(_className);\n  });\n};\n\nexports.AddClasses = AddClasses;\n\nconst RemoveClasses = (elem, classList) => {\n  classList.forEach(_className => {\n    elem.classList.remove(_className);\n  });\n};\n\nexports.RemoveClasses = RemoveClasses;\n\nconst QueryMedia = (mediaQuery, callback = null) => {\n  let query = window.matchMedia(mediaQuery);\n\n  if (callback == null) {\n    return query.matches;\n  } else {\n    callback({\n      matches: query.matches,\n      remove: null\n    });\n\n    let ObserveResult = matches => {\n      callback({\n        matches: matches,\n        // use removeListener to support legacy browsers like 11 \n        //remove: () => query.removeEventListener('change', handler)\n        remove: () => query.removeListener(handler)\n      });\n    };\n\n    let handler = e => {\n      ObserveResult(e.matches);\n    }; // use addListener to support legacy browsers like 11\n\n\n    query.addListener(handler); //query.addEventListener('change', handler);\n  }\n};\n\nexports.QueryMedia = QueryMedia;\n\n},{}],6:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResetMutationObserver = exports.StopMutationObserver = exports.RemoveMutationListener = exports.AddMutationListener = void 0;\nlet mutationObserver = null;\n\n(() => {\n  mutationObserver = new MutationObserver(mutations => {\n    subscribers.forEach(subscriber => {\n      subscriber.callback(mutations);\n    });\n  }); //https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit\n\n  mutationObserver.observe(document, {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: true\n  });\n})();\n\nlet subscribers = []; // {\n//     name: \"\",\n//     callback: method\n// };\n\nconst AddMutationListener = subscriber => {\n  // check if already subscribed\n  let alreadySubscribed = subscribers.some(s => s.name == subscriber.name);\n\n  if (!alreadySubscribed) {\n    subscribers.push(subscriber); // Let's say AnimateIO is initialized at T0 and finds zero elements\n    // Then we add a mutation listener after arbitrary delay of 1000ms\n    // It's definitely possible that some mutations might have taken place in this time\n    // And the elements added in this time didn't get registered\n    // To overcome this issue we will manually execute subscriber callback once\n\n    subscriber.callback();\n  }\n};\n\nexports.AddMutationListener = AddMutationListener;\n\nconst RemoveMutationListener = name => {\n  let index = subscribers.findIndex(s => s.name == name);\n\n  if (index > -1) {\n    subscribers.splice(index, 1);\n  }\n\n  if (subscribers.length == 0) {\n    StopMutationObserver();\n  }\n};\n\nexports.RemoveMutationListener = RemoveMutationListener;\n\nconst StopMutationObserver = () => {\n  mutationObserver.disconnect();\n};\n\nexports.StopMutationObserver = StopMutationObserver;\n\nconst ResetMutationObserver = () => {\n  StopMutationObserver();\n  subscribers = [];\n};\n\nexports.ResetMutationObserver = ResetMutationObserver;\n\n},{}],7:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RestartAnimateIO = exports.DestroyAnimateIO = exports.ResetAnimateIO = exports.KillAllObservers = exports.ObserveElementsContinuous = exports.ObserveElementsOnce = exports.InitAIObservers = void 0;\n\nvar _Settings = require(\"./Settings\");\n\nvar _Helpers = require(\"./Helpers\");\n\nvar _Mutations = require(\"./Mutations\");\n\nlet ObserverList = [];\n\nconst InitAIObservers = () => {\n  // Scan for all AIO Elements & create observer for all of them\n  // Multiple observers so we can individually disconnect any element that we want\n  ObserveAIOElements(); // look for new observable objects \n  // delay observing newly added elements for whatever reasons after a delay of X milliseconds\n\n  if (_Settings.ObserverSettings.trackMutations) {\n    setTimeout(() => AddNewAIOElements(), _Settings.ObserverSettings.mutationWatchDelay);\n  }\n};\n\nexports.InitAIObservers = InitAIObservers;\n\nconst AddNewAIOElements = () => {\n  (0, _Mutations.AddMutationListener)({\n    name: 'observer_listener',\n    callback: mutations => {\n      // attach observers after a light delay\n      setTimeout(() => ObserveAIOElements(), 10);\n    }\n  });\n};\n\nlet helperCounter = 0;\n\nconst ObserveAIOElements = () => {\n  let AIOElements = document.querySelectorAll(`[${_Settings.ObserverSettings.observableAttrName}]`);\n  let elements = Array.from(AIOElements).filter(elem => !elem.hasAttribute('data-aio-id'));\n  elements.forEach((elem, i) => {\n    elem.setAttribute('data-aio-id', `aio_auto_${++helperCounter}_${i}`);\n\n    let repeat = elem.hasAttribute('data-aio-repeat') || _Settings.ObserverSettings.repeat;\n\n    let delay = (0, _Helpers.AttrToNum)(elem, 'data-aio-delay', _Settings.ObserverSettings.delay);\n    let {\n      rootMargin\n    } = _Settings.ObserverSettings;\n\n    if (elem.hasAttribute('data-aio-offset')) {\n      let offsetVal = elem.getAttribute('data-aio-offset');\n\n      if (offsetVal != null && offsetVal.length > 0) {\n        rootMargin = offsetVal;\n      }\n    }\n\n    let intersected = false;\n    let custom_entry_attrVal = (0, _Helpers.GetAttrVal)(elem, 'data-aio-enter-class', '');\n    let entry_classlist = [_Settings.ObserverSettings.enterIntersectionClassName, custom_entry_attrVal.split(' ')];\n    let aioType = elem.getAttribute(_Settings.ObserverSettings.observableAttrName);\n\n    if (aioType.length > 0) {\n      entry_classlist.push(`aio-${aioType}`);\n    }\n\n    entry_classlist = entry_classlist.filter(_class => _class != '');\n    let custom_exit_attrVal = (0, _Helpers.GetAttrVal)(elem, 'data-aio-exit-class', '');\n    let exit_classlist = [_Settings.ObserverSettings.exitIntersectionClassName, custom_exit_attrVal.split(' ')];\n    exit_classlist = exit_classlist.filter(_class => _class != '');\n    let attributesApplied = false;\n    let lazy_attr_list = [];\n    let lazy_attrVal = (0, _Helpers.GetAttrVal)(elem, 'data-aio-lazy-attr', null);\n\n    if (lazy_attrVal != null && lazy_attrVal.length > 10) {\n      let parsed_array = JSON.parse(lazy_attrVal);\n\n      if (Array.isArray(parsed_array)) {\n        if (parsed_array.length > 0) lazy_attr_list.push(...parsed_array);\n      }\n    }\n\n    debugger;\n    let elementToObserve = elem; // watch self or another element(s)\n\n    if (elem.hasAttribute('data-aio-ref')) {\n      let refElems = document.querySelectorAll(elem.getAttribute('data-aio-ref'));\n\n      if (refElems.length > 0) {\n        elementToObserve = refElems;\n      }\n    }\n\n    let intersectionsettings = {\n      root: _Settings.ObserverSettings.root,\n      rootMargin: rootMargin,\n      threshold: _Settings.ObserverSettings.threshold\n    };\n    let Observer = new IntersectionObserver((entries, _observer) => {\n      entries.forEach(entry => {\n        let ratio = entry.intersectionRatio;\n        let entryTimeOut = 0;\n\n        if (ratio > 0) {\n          intersected = true; // add custom attributes\n\n          if (!attributesApplied) {\n            attributesApplied = true;\n            lazy_attr_list.forEach(attr => {\n              let key = Object.keys(attr)[0];\n              elem.setAttribute(key, attr[key]);\n            });\n          } // add entry class names & remove exit class names\n\n\n          entryTimeOut = setTimeout(() => {\n            (0, _Helpers.RemoveClasses)(elem, exit_classlist);\n            (0, _Helpers.AddClasses)(elem, entry_classlist);\n          }, delay);\n        }\n\n        if (ratio == 0 && repeat) {\n          clearTimeout(entryTimeOut); // add exit class names & remove entry class names\n\n          (0, _Helpers.RemoveClasses)(elem, entry_classlist);\n          (0, _Helpers.AddClasses)(elem, exit_classlist);\n        }\n\n        if (ratio == 0 && !repeat && intersected) {\n          _observer.unobserve(elem);\n\n          _observer.disconnect();\n        }\n      });\n    }, intersectionsettings);\n\n    if (NodeList.prototype.isPrototypeOf(elementToObserve)) {\n      // watch multiple objects\n      debugger;\n      elementToObserve.forEach(_elem => {\n        Observer.observe(_elem);\n      });\n    } else {\n      // watch self\n      Observer.observe(elem);\n    }\n\n    ObserverList.push(Observer);\n  });\n};\n\nconst ObserveElements = (target, options, callback, repeat) => {\n  let defaultOptions = {\n    root: null,\n    rootMargin: '0px',\n    threshold: 0,\n    ...options\n  };\n  let observer = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      callback(entry);\n      let ratio = entry.intersectionRatio;\n\n      if (ratio != 0) {\n        if (entry.in) entry.in();\n\n        if (!repeat) {\n          observer.unobserve(entry.target);\n          observer.disconnect();\n        }\n      } else {\n        if (entry.out) entry.out();\n      }\n    });\n  }, defaultOptions);\n\n  if (typeof target == 'string' && target.trim().length > 0) {\n    document.querySelectorAll(target).forEach(elem => observer.observe(elem));\n  } else if (target instanceof Element) {\n    observer.observe(target);\n  } else if (NodeList.prototype.isPrototypeOf(target)) {\n    target.forEach(elem => observer.observe(elem));\n  } else if (HTMLCollection.prototype.isPrototypeOf(target)) {\n    [...target].forEach(elem => observer.observe(elem));\n  } else {\n    console.error(`Target element: '${target}' not found`);\n  }\n};\n\nconst ObserveElementsOnce = (target, options, callback) => {\n  ObserveElements(target, options, callback, false);\n};\n\nexports.ObserveElementsOnce = ObserveElementsOnce;\n\nconst ObserveElementsContinuous = (target, options, callback) => {\n  ObserveElements(target, options, callback, true);\n};\n\nexports.ObserveElementsContinuous = ObserveElementsContinuous;\n\nconst KillAllObservers = () => {\n  ObserverList.forEach(o => {\n    o.disconnect();\n  });\n  ObserverList = [];\n};\n\nexports.KillAllObservers = KillAllObservers;\n\nconst ResetAnimateIO = () => {\n  KillAllObservers();\n\n  let _elems = document.querySelectorAll(`[${_Settings.ObserverSettings.observableAttrName}]`);\n\n  _elems.forEach((elem, i) => {\n    elem.classList.remove(Settings.enterIntersectionClassName);\n    let aioType = elem.getAttribute(_Settings.ObserverSettings.observableAttrName);\n\n    if (aioType.length > 0) {\n      elem.classList.remove(`aio-${aioType}`);\n    }\n  });\n};\n\nexports.ResetAnimateIO = ResetAnimateIO;\n\nconst DestroyAnimateIO = () => {\n  ResetAnimateIO();\n\n  let _elems = document.querySelectorAll(`[${_Settings.ObserverSettings.observableAttrName}]`);\n\n  _elems.forEach((elem, i) => {\n    let {\n      attributes\n    } = elem;\n    Array.from(attributes).forEach(attr => {\n      if (attr.name.indexOf(_Settings.ObserverSettings.observableAttrName) > -1) {\n        elem.removeAttribute(attr.name);\n      }\n    });\n  });\n};\n\nexports.DestroyAnimateIO = DestroyAnimateIO;\n\nconst RestartAnimateIO = () => {\n  ResetAnimateIO();\n  ObserveAIOElements();\n};\n\nexports.RestartAnimateIO = RestartAnimateIO;\n\n},{\"./Helpers\":5,\"./Mutations\":6,\"./Settings\":9}],8:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForceRenderLoop = exports.StopRenderLoop = exports.RenderLoop = exports.InitRenderer = void 0;\n\nvar _AnimationStateMachine = require(\"./AnimationStateMachine\");\n\nvar _Settings = require(\"./Settings\");\n\nlet scrollTop = 0;\nlet scrollTopPrev = -1;\nlet doc = document.documentElement;\nlet raf_id = 0; // Request Animate Frame ID\n\nconst InitRenderer = () => {\n  let useFps = true;\n  let {\n    fps\n  } = _Settings.AnimationSettings;\n\n  if (fps != null) {\n    let num = parseFloat(fps);\n    useFps = !isNaN(num);\n  }\n\n  if (useFps) {\n    (function animationTimeoutUpdate() {\n      RenderLoop();\n      setTimeout(() => {\n        raf_id = requestAnimationFrame(animationTimeoutUpdate);\n      }, 1000 / fps);\n    })();\n  } else {\n    (function animationUpdate() {\n      RenderLoop();\n      raf_id = requestAnimationFrame(animationUpdate);\n    })();\n  }\n};\n\nexports.InitRenderer = InitRenderer;\nlet forceRender = false;\n\nconst RenderLoop = () => {\n  if (_AnimationStateMachine.StateMachine.activeCount == 0) return;\n  scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0); // Exit render loop if no scrolling happened in this frame\n  // Exception: Continue with the render loop if forceRender flag is true\n\n  if (scrollTop == scrollTopPrev && !forceRender) return;\n  scrollTopPrev = scrollTop;\n  document.body.setAttribute(\"data-scroll-top\", scrollTop);\n  forceRender = false;\n\n  let visibleSMObjects = _AnimationStateMachine.StateMachine.elements.filter(entry => entry.ratio > 0);\n\n  visibleSMObjects.forEach(smObject => {\n    let frames = smObject.keyframes;\n    let domElement = smObject.domElement;\n    let elemTop = domElement.offsetTop; //convert offset to absolute\n\n    if (smObject.mode == \"relative\") {\n      frames.forEach((f, i) => {\n        let offset = elemTop + f.offset; //offset -= window.innerHeight;\n\n        f.absOffset = offset;\n        domElement.setAttribute(`data-kf-${i}`, offset);\n      });\n    }\n\n    for (let i = 0; i < frames.length - 1; i++) {\n      let curFrame = frames[i];\n      let nxtFrame = frames[i + 1];\n      let frame1_top = curFrame.absOffset;\n      let frame2_top = nxtFrame.absOffset;\n      let isBefore = scrollTop < frame1_top;\n      let isAfter = scrollTop > frame2_top;\n\n      if (isBefore || isAfter) {\n        //console.log(isBefore, isAfter);\n        let requiredFrame = isBefore ? curFrame : nxtFrame;\n        Object.keys(requiredFrame.props).forEach((key, index) => {\n          let prop = requiredFrame.props[key];\n\n          let value = _interpolateString(prop.value);\n\n          setStyle(domElement, key, value);\n        });\n        return;\n      }\n\n      let progress = (scrollTop - frame1_top) / (frame2_top - frame1_top);\n      Object.keys(curFrame.props).forEach(key => {\n        let interpolatedValue = _calcInterpolation(curFrame.props[key].value, nxtFrame.props[key].value, progress);\n\n        let value = _interpolateString(interpolatedValue);\n\n        setStyle(domElement, key, value);\n      });\n    }\n  });\n};\n\nexports.RenderLoop = RenderLoop;\n\nlet _calcInterpolation = (val1, val2, progress) => {\n  var valueIndex;\n  var val1Length = val1.length; //They both need to have the same length\n\n  if (val1Length !== val2.length) {\n    throw 'Can\\'t interpolate between \"' + val1[0] + '\" and \"' + val2[0] + '\"';\n  } //Add the format string as first element.\n\n\n  var interpolated = [val1[0]];\n  valueIndex = 1;\n\n  for (; valueIndex < val1Length; valueIndex++) {\n    //That's the line where the two numbers are actually interpolated.\n    interpolated[valueIndex] = val1[valueIndex] + (val2[valueIndex] - val1[valueIndex]) * progress;\n  }\n\n  return interpolated;\n};\n\nlet _interpolateString = val => {\n  let i = 1;\n  return val[0].replace(/\\{\\?\\}/g, () => {\n    return val[i++];\n  });\n};\n\nlet setStyle = (elem, key, value) => {\n  let style = elem.style; // Extract \"-x\", \"-m\" from string \"abc-xyz-mno\" \n\n  let match = key.match(/-./g);\n\n  if (match != null) {\n    // convert font-size to fontSize\n    let uprCs = match[0].toUpperCase();\n    let prop = key.replace(match[0], uprCs).replace('-', '');\n    style[prop] = value;\n  } else {\n    style[key] = value;\n  }\n};\n\nconst StopRenderLoop = () => {\n  cancelAnimationFrame(raf_id);\n}; // Force rederloop when new elements are added to statemachine\n\n\nexports.StopRenderLoop = StopRenderLoop;\n\nconst ForceRenderLoop = () => {\n  forceRender = true;\n};\n\nexports.ForceRenderLoop = ForceRenderLoop;\n\n},{\"./AnimationStateMachine\":3,\"./Settings\":9}],9:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OverrideDefaultAnimationSettings = exports.AnimationSettings = exports.OverrideDefaultObserverSettings = exports.ObserverSettings = void 0;\nconst DefaultObserverSettings = {\n  delay: 0,\n  observableAttrName: \"data-aiobserve\",\n  enterIntersectionClassName: \"aio-enter\",\n  exitIntersectionClassName: \"aio-exit\",\n  repeat: false,\n  trackMutations: true,\n  mutationWatchDelay: 0,\n  root: null,\n  rootMargin: '0px 0px 0px 0px',\n  threshold: 0\n};\nlet ObserverSettings = null;\nexports.ObserverSettings = ObserverSettings;\n\nconst OverrideDefaultObserverSettings = _settings => {\n  exports.ObserverSettings = ObserverSettings = { ...DefaultObserverSettings,\n    ..._settings\n  };\n  return ObserverSettings;\n};\n\nexports.OverrideDefaultObserverSettings = OverrideDefaultObserverSettings;\nconst DefaultAnimationSettings = {\n  mode: 'relative',\n  fps: null,\n  activeRange: '(min-width: 1025px)',\n  trackMutations: true,\n  mutationWatchDelay: 0,\n  gridHelper: false\n};\nlet AnimationSettings = null;\nexports.AnimationSettings = AnimationSettings;\n\nconst OverrideDefaultAnimationSettings = _settings => {\n  exports.AnimationSettings = AnimationSettings = { ...DefaultAnimationSettings,\n    ..._settings\n  };\n  return AnimationSettings;\n};\n\nexports.OverrideDefaultAnimationSettings = OverrideDefaultAnimationSettings;\n\n},{}]},{},[1])\n\n","import { OverrideDefaultObserverSettings, OverrideDefaultAnimationSettings } from './modules/Settings';\r\nimport { ObserveElementsOnce, ObserveElementsContinuous, KillAllObservers, RestartAnimateIO, DestroyAnimateIO, InitAIObservers } from './modules/ObserverManager';\r\nimport { InitAnimations, KillAnimateInstance, RestartAnimateInstance } from './modules/AnimationManager';\r\n\r\n((window) => {\r\n    let InitObservers = (_settings) => {\r\n\r\n        // override settings passed from initialization\r\n        OverrideDefaultObserverSettings(_settings);\r\n\r\n        // scan for observable elements, attach intersection observer to each\r\n        InitAIObservers();\r\n    }\r\n\r\n    let Animate = (_settings) => {\r\n\r\n        // override settings passed from initialization\r\n        OverrideDefaultAnimationSettings(_settings);\r\n\r\n        // scan for animateable elements, build the state machine, init rendering\r\n        InitAnimations();\r\n    }\r\n\r\n    window.AnimateIO = {\r\n        InitObservers: InitObservers,\r\n        Observe: ObserveElementsContinuous,\r\n        ObserveOnce: ObserveElementsOnce,\r\n        StopObservers: KillAllObservers,\r\n        DestroyObservers: DestroyAnimateIO,\r\n        RestartObservers: RestartAnimateIO,\r\n        Animate: Animate,\r\n        AnimateEnd: KillAnimateInstance,\r\n        AnimateRestart: RestartAnimateInstance\r\n    };\r\n})(window);","import { InitAnimationStateMachine, InitiateAnimationObserver, ObserveStateMachineObjects, ResetStateMachine, StopAnimationObserver, UpdateStateMachine } from './AnimationStateMachine';\r\nimport { DrawGrid, QueryMedia } from './Helpers';\r\nimport { AddMutationListener, ResetMutationObserver } from './Mutations';\r\nimport { InitRenderer, StopRenderLoop } from './Render';\r\nimport { AnimationSettings } from './Settings';\r\n\r\nlet AnimationsInitialized = false;\r\nexport const InitAnimations = () => {\r\n    if (AnimationsInitialized) {\r\n        console.error('AnimateIO.Animate() already initialized. To start a new instance, please stop the current animations instance using:\\nAnimateIO.StopAnimations();')\r\n    }\r\n\r\n    // Check if browser dimensions are correct\r\n    let canInitialize = QueryMedia(AnimationSettings.activeRange);\r\n    if (!canInitialize) {\r\n        console.log(`AnimateIO.Animate() can't initialize since the screen width is outside the range: ${AnimationSettings.activeRange}`);\r\n        return;\r\n    }\r\n\r\n    // Initiate animation observer\r\n    InitiateAnimationObserver();\r\n\r\n    //scan for animateable elements, build the state machine\r\n    InitAnimationStateMachine();\r\n\r\n    // attach an observer to all the elements added to the State Machine\r\n    ObserveStateMachineObjects();\r\n\r\n    // init rendering for all the elements\r\n    InitRenderer();\r\n\r\n    // look for new animateable objects with the signature data-aio-<int>\r\n    // start looking for new elements after an arbitrary delay of 2 seconds\r\n    if (AnimationSettings.trackMutations) {\r\n        setTimeout(() => AddNewElementsToStateMachine(), AnimationSettings.mutationWatchDelay);\r\n    }\r\n\r\n    // show a helper grid and markers for where an animation will start and end\r\n    if (AnimationSettings.gridHelper) {\r\n        setTimeout(() => DrawGrid(), 1000);\r\n    }\r\n\r\n    AnimationsInitialized = true;\r\n\r\n    // Check for browser resolution changes    \r\n    WatchBrowserResize();\r\n}\r\n\r\n\r\nconst AddNewElementsToStateMachine = () => {\r\n    AddMutationListener({\r\n        name: 'animations_listener',\r\n        callback: (mutations) => {\r\n            UpdateStateMachine();\r\n        }\r\n    })\r\n}\r\n\r\n\r\nconst WatchBrowserResize = () => {\r\n    QueryMedia(AnimationSettings.activeRange, (response) => {\r\n        \r\n        if(response.matches) {\r\n            // Start animations if not already initialized\r\n            if(!AnimationsInitialized) {\r\n                if (response.remove != null) {\r\n                    response.remove();\r\n                    console.log(`Restarting AnimateIO.Animate as browser width is inside the acceptable range: ${AnimationSettings.activeRange}px`);\r\n                    InitAnimations();\r\n                }\r\n            }            \r\n        } else {\r\n            // stop the animations if browser window shrinks below defined width\r\n            if(AnimationsInitialized) {\r\n                console.log(`Stopping AnimateIO.Animate as browser width is outside the range: ${AnimationSettings.activeRange}`);\r\n                KillAnimateInstance();\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport const KillAnimateInstance = () => {\r\n\r\n    // stop rendering\r\n    StopRenderLoop();\r\n\r\n    // Stop animation intersection observer\r\n    StopAnimationObserver();\r\n\r\n    // disconnect mutation observer\r\n    ResetMutationObserver();\r\n\r\n    // reset state machine & remove state machine id attribute\r\n    ResetStateMachine();\r\n\r\n    AnimationsInitialized = false;\r\n}\r\n\r\nexport const RestartAnimateInstance = () => {\r\n    KillAnimateInstance();\r\n    InitAnimations();\r\n}\r\n\r\n\r\n","import { SMO_ID_ATTR_NAME } from './Constants';\r\nimport { ForceRenderLoop } from './Render';\r\nimport { AnimationSettings } from './Settings';\r\n\r\nexport const StateMachine = {\r\n    activeCount: 0,\r\n    elements: [],\r\n    singleFrameElements: []\r\n}\r\n\r\nexport const InitAnimationStateMachine = () => {\r\n    // filter out data-aio-<int> elements and push them to the StateMachine so that we can track them later\r\n    populateStateMachine((count) => {\r\n        console.log(`${count} animateable elements found`);\r\n    });\r\n}\r\n\r\nexport const UpdateStateMachine = (callback = null) => {\r\n    populateStateMachine((count) => {\r\n        console.log(`${count} new animateable elements found`);\r\n        ObserveStateMachineObjects();\r\n\r\n        // Wait for observers to get attached to new elements\r\n        setTimeout(() => ForceRenderLoop(), 100);\r\n    });\r\n}\r\n\r\n// State Machine Object Template\r\nconst SMOTemplate = {\r\n    id: '',\r\n    domElement: null,\r\n    ratio: 0,\r\n    repeat: true,\r\n    keyframes: [],\r\n    observerAttached: false\r\n}\r\n\r\nlet populateCounter = 0; // use this counter to generate unique ids for elements\r\n\r\nconst populateStateMachine = (done) => {\r\n    let AllElements = document.getElementsByTagName(\"*\");\r\n\r\n    // Filter elements with the signature: data-aio-<int>\r\n    // Example: data-aio-1000, data-aio-0\r\n    let AIOElements = [...AllElements].filter(elem => {\r\n        let attributes = Object.entries(elem.attributes).map(a => a[1])\r\n        return attributes.some(f => (/^data-aio--?[0-9]+/g).test(f.name));\r\n    });\r\n\r\n    // remove elements which have already been added & tracked inside animation state machien list\r\n    let _elements = AIOElements.filter(elem => !elem.hasAttribute(SMO_ID_ATTR_NAME));\r\n\r\n    _elements.forEach((elem, i) => {\r\n        let { attributes } = elem;\r\n\r\n        let keyframes = Array.from(attributes).filter(attr => (/^data-aio--?[0-9]+/g).test(attr.name));\r\n\r\n        let id = `aio-pl-${++populateCounter}-${i}`;\r\n        elem.setAttribute(SMO_ID_ATTR_NAME, id);\r\n\r\n        let entry = { ...SMOTemplate };\r\n\r\n        let mode = AnimationSettings.mode;\r\n        if (elem.hasAttribute('data-aio-mode')) {\r\n            let _mode = elem.getAttribute('data-aio-mode');\r\n            if (_mode.length > 0) mode = _mode;\r\n        }\r\n\r\n        entry.id = id;\r\n        entry.mode = mode;\r\n        entry.repeat = elem.hasAttribute('data-aio-repeat');\r\n        entry.domElement = elem;\r\n        entry.keyframes = processKeyFrames(keyframes, elem, mode);\r\n        entry.observerAttached = false;\r\n\r\n\r\n        if (keyframes.length == 1) {\r\n            StateMachine.singleFrameElements.push(entry);\r\n        } else {\r\n            StateMachine.elements.push(entry);\r\n        }\r\n    });\r\n\r\n    done(_elements.length);\r\n}\r\n\r\n\r\nconst processKeyFrames = (kf, elem, elem_mode) => {\r\n    let frames = [];\r\n    kf.forEach((f, i) => {\r\n        let _props = {}\r\n\r\n        f.value.trim().split(\";\").forEach(p => {\r\n            if (p.length > 0) {\r\n                let key = p.split(\":\")[0].trim();\r\n                let val = p.split(\":\")[1].trim();\r\n\r\n                let numbers = [];\r\n                //Now parse ANY number inside this string and create a format string.\r\n                val = val.replace(/[\\-+]?[\\d]*\\.?[\\d]+/g, (n) => {\r\n                    numbers.push(+n);\r\n                    return '{?}';\r\n                });\r\n\r\n                //Add the formatstring as first value.\r\n                numbers.unshift(val);\r\n\r\n                _props[key] = {\r\n                    value: numbers\r\n                }\r\n            }\r\n        });\r\n\r\n        let _offset = parseInt(f.name.replace('data-aio-', ''));\r\n        frames.push({\r\n            offset: _offset,\r\n            absOffset: _offset,\r\n            props: _props\r\n        })\r\n\r\n        elem.setAttribute(`data-kf-${i}`, _offset);\r\n    });\r\n\r\n    //convert offset to absolute\r\n    if (elem_mode == \"relative\") {\r\n        frames.forEach((f, i) => {\r\n            let offset = elem.offsetTop + f.offset - window.innerHeight;\r\n            f.absOffset = offset;\r\n            elem.setAttribute(`data-kf-${i}`, offset);\r\n        })\r\n    }\r\n\r\n    frames.sort((a, b) => a.absOffset > b.absOffset ? 1 : b.absOffset > a.absOffset ? -1 : 0);\r\n\r\n    // handle missing props between frames\r\n    let frameIndex = 0;\r\n    let propList = {};\r\n\r\n    //iterate from left to right\r\n    for (; frameIndex < frames.length; frameIndex++) {\r\n        _fillPropForFrame(frames[frameIndex], propList);\r\n    }\r\n\r\n    //iterate from right to left\r\n    propList = {};\r\n    frameIndex--;\r\n    for (; frameIndex >= 0; frameIndex--) {\r\n        _fillPropForFrame(frames[frameIndex], propList);\r\n    }\r\n\r\n    return frames;\r\n}\r\n\r\n\r\nlet _fillPropForFrame = function (frame, propList) {\r\n    var key;\r\n\r\n    //For each key frame iterate over all right hand properties and assign them,\r\n    //but only if the current key frame doesn't have the property by itself\r\n    for (key in propList) {\r\n        //The current frame misses this property, so assign it.\r\n        if (!Object.prototype.hasOwnProperty.call(frame.props, key)) {\r\n            frame.props[key] = propList[key];\r\n        }\r\n    }\r\n\r\n    //Iterate over all props of the current frame and collect them\r\n    for (key in frame.props) {\r\n        propList[key] = frame.props[key];\r\n    }\r\n}\r\n\r\n\r\nlet AnimationObserver = null;\r\nexport const InitiateAnimationObserver = () => {\r\n    let observerSettings = { root: null, rootMargin: '0px', threshold: 0 }\r\n    // init observer\r\n    AnimationObserver = new IntersectionObserver((entries, observer) => {\r\n        //console.log(entries)\r\n        entries.forEach(entry => {\r\n            let elem = entry.target;\r\n            let aioPlId = elem.getAttribute(SMO_ID_ATTR_NAME);\r\n\r\n            let stateMachineObject = StateMachine.elements.filter(o => o.id == aioPlId)[0];\r\n\r\n            let intersected = false;\r\n            let ratio = entry.intersectionRatio;\r\n            stateMachineObject.ratio = ratio;\r\n            elem.setAttribute('data-ratio', ratio);\r\n\r\n            if (ratio > 0) {\r\n                intersected = true;\r\n                StateMachine.activeCount++;\r\n            }\r\n\r\n            if (ratio == 0 && intersected) {\r\n                StateMachine.activeCount--;\r\n\r\n                if (!stateMachineObject.repeat) {\r\n                    observer.unobserve(elem);\r\n\r\n                    let smoIndex = StateMachine.elements.findIndex(o => o.id == aioPlId);\r\n                    StateMachine.elements.splice(smoIndex, 1);\r\n                }\r\n            }\r\n        })\r\n    }, observerSettings);\r\n}\r\n\r\nexport const ObserveStateMachineObjects = () => {\r\n    if (StateMachine.elements.length > 0) {\r\n        let newStateMachineElements = StateMachine.elements.filter(elem => !elem.observerAttached);\r\n        newStateMachineElements.forEach(elem => {\r\n            AnimationObserver.observe(elem.domElement);\r\n            elem.observerAttached = true;\r\n        });\r\n    }\r\n}\r\n\r\nexport const StopAnimationObserver = () => {\r\n    AnimationObserver.disconnect();\r\n}\r\n\r\nconst RemoveSMOAttributes = () => {\r\n    let StateMachineObjects = [...StateMachine.elements, ...StateMachine.singleFrameElements];\r\n\r\n    StateMachineObjects.forEach(smo => {\r\n        smo.domElement.removeAttribute(SMO_ID_ATTR_NAME);\r\n    })\r\n}\r\n\r\nexport const ResetStateMachine = () => {\r\n    RemoveSMOAttributes();\r\n\r\n    StateMachine.activeCount = 0;\r\n    StateMachine.elements = [];\r\n    StateMachine.singleFrameElements = [];\r\n}\r\n\r\n","export const SMO_ID_ATTR_NAME = 'data-aio-smo-id';","export const GetAttrVal = (elem, attr, defaultValue) => {\r\n    let val = defaultValue;\r\n    if (elem.hasAttribute(attr)) {\r\n        let attrval = elem.getAttribute(attr);\r\n        if (attrval != null) {\r\n            val = attrval;\r\n        }\r\n    }\r\n    return val;\r\n}\r\n\r\nexport const AttrToNum = (elem, attr, defaultValue) => {\r\n    let val = GetAttrVal(elem, attr, defaultValue);\r\n    let num = parseInt(val);\r\n    return Number.isNaN(num) ? defaultValue : num;\r\n}\r\n\r\nexport const DrawGrid = () => {\r\n    let gridContainer = document.createElement('div');\r\n    gridContainer.id = \"aio-grid-container\";\r\n\r\n    let h = document.documentElement.scrollHeight;\r\n    for (let i = 0; i < h; i += 100) {\r\n        let div = document.createElement('div');\r\n        div.className = \"aio-row\";\r\n        div.innerHTML = `<div class=\"num\">${i}</div><div class=\"num\">${i}</div>`;\r\n        gridContainer.appendChild(div);\r\n    }\r\n\r\n    document.body.appendChild(gridContainer);\r\n}\r\n\r\nexport const AddClasses = (elem, classList) => {\r\n    classList.forEach(_className => {\r\n        elem.classList.add(_className);\r\n    });\r\n}\r\n\r\nexport const RemoveClasses = (elem, classList) => {\r\n    classList.forEach(_className => {\r\n        elem.classList.remove(_className);\r\n    });\r\n}\r\n\r\n\r\nexport const QueryMedia = (mediaQuery, callback = null) => {\r\n    let query = window.matchMedia(mediaQuery);\r\n\r\n    if (callback == null) {\r\n        return query.matches;\r\n    } else {\r\n        callback({ matches: query.matches, remove: null });\r\n\r\n\r\n\r\n        let ObserveResult = (matches) => {\r\n            callback({\r\n                matches: matches,\r\n                // use removeListener to support legacy browsers like 11 \r\n                //remove: () => query.removeEventListener('change', handler)\r\n                remove: () => query.removeListener(handler) \r\n            });\r\n        }\r\n\r\n        let handler = (e) => {\r\n            ObserveResult(e.matches)\r\n        }\r\n\r\n        // use addListener to support legacy browsers like 11\r\n        query.addListener(handler);\r\n        //query.addEventListener('change', handler);\r\n\r\n    }\r\n}","let mutationObserver = null;\r\n\r\n(() => {\r\n    mutationObserver = new MutationObserver(mutations => {\r\n        subscribers.forEach(subscriber => {\r\n            subscriber.callback(mutations);\r\n        })\r\n    });\r\n\r\n    //https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit\r\n    mutationObserver.observe(document, {\r\n        attributes: false,\r\n        childList: true,\r\n        subtree: true,\r\n        characterData: true\r\n    });\r\n})();\r\n\r\nlet subscribers = [];\r\n// {\r\n//     name: \"\",\r\n//     callback: method\r\n// };\r\n\r\nexport const AddMutationListener = (subscriber) => {\r\n\r\n    // check if already subscribed\r\n    let alreadySubscribed = subscribers.some(s => s.name == subscriber.name)\r\n\r\n    if (!alreadySubscribed) {\r\n        subscribers.push(subscriber);\r\n\r\n        // Let's say AnimateIO is initialized at T0 and finds zero elements\r\n        // Then we add a mutation listener after arbitrary delay of 1000ms\r\n        // It's definitely possible that some mutations might have taken place in this time\r\n        // And the elements added in this time didn't get registered\r\n        // To overcome this issue we will manually execute subscriber callback once\r\n        subscriber.callback();\r\n    }\r\n}\r\n\r\nexport const RemoveMutationListener = (name) => {\r\n    let index = subscribers.findIndex(s => s.name == name);\r\n    if(index > -1) {\r\n        subscribers.splice(index, 1);\r\n    }\r\n\r\n    if(subscribers.length == 0) {\r\n        StopMutationObserver();\r\n    }\r\n}\r\n\r\n\r\nexport const StopMutationObserver = () => {\r\n    mutationObserver.disconnect();\r\n}\r\n\r\nexport const ResetMutationObserver = () => {\r\n    StopMutationObserver();\r\n    subscribers = [];\r\n}","import { ObserverSettings } from './Settings';\r\nimport { AddClasses, AttrToNum, GetAttrVal, RemoveClasses } from './Helpers';\r\nimport { AddMutationListener } from './Mutations';\r\n\r\nlet ObserverList = [];\r\n\r\n\r\nexport const InitAIObservers = () => {\r\n\r\n    // Scan for all AIO Elements & create observer for all of them\r\n    // Multiple observers so we can individually disconnect any element that we want\r\n    ObserveAIOElements();\r\n\r\n\r\n    // look for new observable objects \r\n    // delay observing newly added elements for whatever reasons after a delay of X milliseconds\r\n    if (ObserverSettings.trackMutations) {\r\n        setTimeout(() => AddNewAIOElements(), ObserverSettings.mutationWatchDelay);\r\n    }\r\n}\r\n\r\nconst AddNewAIOElements = () => {\r\n    AddMutationListener({\r\n        name: 'observer_listener',\r\n        callback: (mutations) => {\r\n            // attach observers after a light delay\r\n            setTimeout(() => ObserveAIOElements(), 10);\r\n        }\r\n    })\r\n}\r\n\r\nlet helperCounter = 0;\r\n\r\nconst ObserveAIOElements = () => {\r\n\r\n    let AIOElements = document.querySelectorAll(`[${ObserverSettings.observableAttrName}]`);\r\n    let elements = Array.from(AIOElements).filter(elem => !elem.hasAttribute('data-aio-id'));\r\n\r\n    elements.forEach((elem, i) => {\r\n        elem.setAttribute('data-aio-id', `aio_auto_${++helperCounter}_${i}`);\r\n\r\n        let repeat = elem.hasAttribute('data-aio-repeat') || ObserverSettings.repeat;\r\n        let delay = AttrToNum(elem, 'data-aio-delay', ObserverSettings.delay);\r\n        let { rootMargin } = ObserverSettings;\r\n        if (elem.hasAttribute('data-aio-offset')) {\r\n            let offsetVal = elem.getAttribute('data-aio-offset');\r\n            if (offsetVal != null && offsetVal.length > 0) {\r\n                rootMargin = offsetVal;\r\n            }\r\n        }\r\n        let intersected = false;\r\n\r\n        let custom_entry_attrVal = GetAttrVal(elem, 'data-aio-enter-class', '');\r\n        let entry_classlist = [ObserverSettings.enterIntersectionClassName, custom_entry_attrVal.split(' ')];\r\n        let aioType = elem.getAttribute(ObserverSettings.observableAttrName);\r\n        if (aioType.length > 0) {\r\n            entry_classlist.push(`aio-${aioType}`);\r\n        }\r\n        entry_classlist = entry_classlist.filter(_class => _class != '');\r\n\r\n        let custom_exit_attrVal = GetAttrVal(elem, 'data-aio-exit-class', '');\r\n        let exit_classlist = [ObserverSettings.exitIntersectionClassName, custom_exit_attrVal.split(' ')];\r\n        exit_classlist = exit_classlist.filter(_class => _class != '');\r\n\r\n        let attributesApplied = false;\r\n        let lazy_attr_list = [];\r\n        let lazy_attrVal = GetAttrVal(elem, 'data-aio-lazy-attr', null);\r\n        if (lazy_attrVal != null && lazy_attrVal.length > 10) {\r\n            let parsed_array = JSON.parse(lazy_attrVal);\r\n            if (Array.isArray(parsed_array)) {\r\n                if (parsed_array.length > 0) lazy_attr_list.push(...parsed_array);\r\n            }\r\n        }\r\n\r\n        debugger;\r\n        let elementToObserve = elem;\r\n        // watch self or another element(s)\r\n        if (elem.hasAttribute('data-aio-ref')) {\r\n            let refElems = document.querySelectorAll(elem.getAttribute('data-aio-ref'));\r\n            if (refElems.length > 0) {\r\n                elementToObserve = refElems;\r\n            }\r\n        }\r\n\r\n        let intersectionsettings = {\r\n            root: ObserverSettings.root,\r\n            rootMargin: rootMargin,\r\n            threshold: ObserverSettings.threshold\r\n        }\r\n\r\n        let Observer = new IntersectionObserver((entries, _observer) => {\r\n            entries.forEach(entry => {\r\n                let ratio = entry.intersectionRatio;\r\n                let entryTimeOut = 0;\r\n\r\n                if (ratio > 0) {\r\n                    intersected = true;\r\n\r\n                    // add custom attributes\r\n                    if (!attributesApplied) {\r\n                        attributesApplied = true;\r\n                        lazy_attr_list.forEach(attr => {\r\n                            let key = Object.keys(attr)[0];\r\n                            elem.setAttribute(key, attr[key]);\r\n                        });\r\n                    }\r\n\r\n                    // add entry class names & remove exit class names\r\n                    entryTimeOut = setTimeout(() => {\r\n                        RemoveClasses(elem, exit_classlist);\r\n                        AddClasses(elem, entry_classlist);\r\n                    }, delay);\r\n                }\r\n\r\n                if (ratio == 0 && repeat) {\r\n                    clearTimeout(entryTimeOut);\r\n\r\n                    // add exit class names & remove entry class names\r\n                    RemoveClasses(elem, entry_classlist);\r\n                    AddClasses(elem, exit_classlist);\r\n                }\r\n\r\n                if (ratio == 0 && !repeat && intersected) {\r\n                    _observer.unobserve(elem);\r\n                    _observer.disconnect();\r\n                }\r\n            })\r\n        }, intersectionsettings);\r\n\r\n\r\n        if (NodeList.prototype.isPrototypeOf(elementToObserve)) {\r\n            // watch multiple objects\r\n            debugger;\r\n            elementToObserve.forEach(_elem => {                \r\n                Observer.observe(_elem);\r\n            })\r\n        } else {\r\n            // watch self\r\n            Observer.observe(elem);\r\n        }\r\n\r\n        ObserverList.push(Observer);\r\n    });\r\n}\r\n\r\nconst ObserveElements = (target, options, callback, repeat) => {\r\n    let defaultOptions = {\r\n        root: null,\r\n        rootMargin: '0px',\r\n        threshold: 0,\r\n        ...options\r\n    }\r\n    let observer = new IntersectionObserver((entries, observer) => {\r\n        entries.forEach(entry => {\r\n            callback(entry);\r\n\r\n            let ratio = entry.intersectionRatio;\r\n            if (ratio != 0) {\r\n                if (entry.in) entry.in();\r\n                if (!repeat) {\r\n                    observer.unobserve(entry.target);\r\n                    observer.disconnect();\r\n                }\r\n            } else {\r\n                if (entry.out) entry.out();\r\n            }\r\n        })\r\n    }, defaultOptions);\r\n\r\n    if (typeof target == 'string' && target.trim().length > 0) {\r\n        document.querySelectorAll(target).forEach(elem => observer.observe(elem));\r\n    } else if (target instanceof Element) {\r\n        observer.observe(target);\r\n    } else if (NodeList.prototype.isPrototypeOf(target)) {\r\n        target.forEach(elem => observer.observe(elem));\r\n    } else if (HTMLCollection.prototype.isPrototypeOf(target)) {\r\n        [...target].forEach(elem => observer.observe(elem));\r\n    } else {\r\n        console.error(`Target element: '${target}' not found`);\r\n    }\r\n}\r\n\r\nexport const ObserveElementsOnce = (target, options, callback) => {\r\n    ObserveElements(target, options, callback, false);\r\n}\r\n\r\nexport const ObserveElementsContinuous = (target, options, callback) => {\r\n    ObserveElements(target, options, callback, true);\r\n}\r\n\r\n\r\n\r\nexport const KillAllObservers = () => {\r\n    ObserverList.forEach(o => {\r\n        o.disconnect();\r\n    });\r\n\r\n    ObserverList = [];\r\n}\r\n\r\nexport const ResetAnimateIO = () => {\r\n    KillAllObservers();\r\n    let _elems = document.querySelectorAll(`[${ObserverSettings.observableAttrName}]`);\r\n    _elems.forEach((elem, i) => {\r\n        elem.classList.remove(Settings.enterIntersectionClassName);\r\n\r\n        let aioType = elem.getAttribute(ObserverSettings.observableAttrName);\r\n        if (aioType.length > 0) {\r\n            elem.classList.remove(`aio-${aioType}`);\r\n        }\r\n    });\r\n}\r\n\r\nexport const DestroyAnimateIO = () => {\r\n    ResetAnimateIO();\r\n    let _elems = document.querySelectorAll(`[${ObserverSettings.observableAttrName}]`);\r\n    _elems.forEach((elem, i) => {\r\n        let { attributes } = elem;\r\n        Array.from(attributes).forEach(attr => {\r\n            if (attr.name.indexOf(ObserverSettings.observableAttrName) > -1) {\r\n                elem.removeAttribute(attr.name);\r\n            }\r\n        })\r\n    });\r\n}\r\n\r\nexport const RestartAnimateIO = () => {\r\n    ResetAnimateIO();\r\n    ObserveAIOElements();\r\n}\r\n","import { StateMachine } from './AnimationStateMachine'\r\nimport { AnimationSettings } from './Settings';\r\n\r\n\r\nlet scrollTop = 0;\r\nlet scrollTopPrev = -1;\r\nlet doc = document.documentElement;\r\nlet raf_id = 0; // Request Animate Frame ID\r\n\r\nexport const InitRenderer = () => {\r\n\r\n    let useFps = true;\r\n    let { fps } = AnimationSettings;\r\n\r\n    if (fps != null) {\r\n        let num = parseFloat(fps);\r\n        useFps = !isNaN(num);\r\n    }\r\n\r\n    if (useFps) {\r\n        (function animationTimeoutUpdate() {\r\n            RenderLoop();\r\n            setTimeout(() => {\r\n                raf_id = requestAnimationFrame(animationTimeoutUpdate);\r\n            }, 1000 / fps);\r\n        }());\r\n    } else {\r\n        (function animationUpdate() {\r\n            RenderLoop();\r\n            raf_id = requestAnimationFrame(animationUpdate);\r\n        }());\r\n    }\r\n}\r\n\r\nlet forceRender = false;\r\n\r\nexport const RenderLoop = () => {\r\n    if (StateMachine.activeCount == 0) return;\r\n\r\n    scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\r\n\r\n    // Exit render loop if no scrolling happened in this frame\r\n    // Exception: Continue with the render loop if forceRender flag is true\r\n    if (scrollTop == scrollTopPrev && !forceRender) return;\r\n    scrollTopPrev = scrollTop;\r\n    document.body.setAttribute(\"data-scroll-top\", scrollTop);\r\n    forceRender = false;\r\n\r\n    let visibleSMObjects = StateMachine.elements.filter(entry => entry.ratio > 0);\r\n\r\n    visibleSMObjects.forEach(smObject => {\r\n        let frames = smObject.keyframes;\r\n        let domElement = smObject.domElement;\r\n        let elemTop = domElement.offsetTop;\r\n\r\n        //convert offset to absolute\r\n        if (smObject.mode == \"relative\") {\r\n            frames.forEach((f, i) => {\r\n                let offset = elemTop + f.offset;\r\n                //offset -= window.innerHeight;\r\n                f.absOffset = offset;\r\n                domElement.setAttribute(`data-kf-${i}`, offset);\r\n            })\r\n        }\r\n\r\n        for (let i = 0; i < frames.length - 1; i++) {\r\n            let curFrame = frames[i];\r\n            let nxtFrame = frames[i + 1];\r\n\r\n            let frame1_top = curFrame.absOffset;\r\n            let frame2_top = nxtFrame.absOffset;\r\n\r\n            let isBefore = scrollTop < frame1_top;\r\n            let isAfter = scrollTop > frame2_top;\r\n\r\n            if (isBefore || isAfter) {\r\n                //console.log(isBefore, isAfter);\r\n                let requiredFrame = isBefore ? curFrame : nxtFrame;\r\n\r\n                Object.keys(requiredFrame.props).forEach((key, index) => {\r\n                    let prop = requiredFrame.props[key];\r\n                    let value = _interpolateString(prop.value);\r\n                    setStyle(domElement, key, value);\r\n                })\r\n                return;\r\n            }\r\n\r\n            let progress = (scrollTop - frame1_top) / (frame2_top - frame1_top);\r\n\r\n            Object.keys(curFrame.props).forEach(key => {\r\n                let interpolatedValue = _calcInterpolation(curFrame.props[key].value, nxtFrame.props[key].value, progress);\r\n                let value = _interpolateString(interpolatedValue);\r\n                setStyle(domElement, key, value);\r\n            })\r\n        }\r\n    });\r\n}\r\n\r\nlet _calcInterpolation = (val1, val2, progress) => {\r\n    var valueIndex;\r\n    var val1Length = val1.length;\r\n\r\n    //They both need to have the same length\r\n    if (val1Length !== val2.length) {\r\n        throw 'Can\\'t interpolate between \"' + val1[0] + '\" and \"' + val2[0] + '\"';\r\n    }\r\n\r\n    //Add the format string as first element.\r\n    var interpolated = [val1[0]];\r\n\r\n    valueIndex = 1;\r\n\r\n    for (; valueIndex < val1Length; valueIndex++) {\r\n        //That's the line where the two numbers are actually interpolated.\r\n        interpolated[valueIndex] = val1[valueIndex] + ((val2[valueIndex] - val1[valueIndex]) * progress);\r\n    }\r\n\r\n    return interpolated;\r\n};\r\n\r\nlet _interpolateString = (val) => {\r\n    let i = 1;\r\n    return val[0].replace(/\\{\\?\\}/g, () => {\r\n        return val[i++];\r\n    });\r\n};\r\n\r\nlet setStyle = (elem, key, value) => {\r\n    let style = elem.style;\r\n\r\n    // Extract \"-x\", \"-m\" from string \"abc-xyz-mno\" \r\n    let match = key.match(/-./g);\r\n    if (match != null) {\r\n        // convert font-size to fontSize\r\n        let uprCs = match[0].toUpperCase();\r\n        let prop = key.replace(match[0], uprCs).replace('-', '');\r\n        style[prop] = value;   \r\n    } else {\r\n        style[key] = value;     \r\n    }\r\n}\r\n\r\n\r\nexport const StopRenderLoop = () => {\r\n    cancelAnimationFrame(raf_id);\r\n}\r\n\r\n// Force rederloop when new elements are added to statemachine\r\nexport const ForceRenderLoop = () => {\r\n    forceRender = true;\r\n}","const DefaultObserverSettings = {\r\n    delay: 0,\r\n    observableAttrName: \"data-aiobserve\",\r\n    enterIntersectionClassName: \"aio-enter\",\r\n    exitIntersectionClassName: \"aio-exit\",\r\n    repeat: false,\r\n    trackMutations: true,\r\n    mutationWatchDelay: 0,\r\n    root: null,\r\n    rootMargin: '0px 0px 0px 0px',\r\n    threshold: 0\r\n}\r\n\r\nexport let ObserverSettings = null;\r\n\r\nexport const OverrideDefaultObserverSettings = (_settings) => {\r\n    ObserverSettings = { ...DefaultObserverSettings, ..._settings };\r\n    return ObserverSettings;\r\n}\r\n\r\n\r\nconst DefaultAnimationSettings = {\r\n    mode: 'relative',\r\n    fps: null,\r\n    activeRange: '(min-width: 1025px)',\r\n    trackMutations: true,\r\n    mutationWatchDelay: 0,\r\n    gridHelper: false\r\n}\r\n\r\nexport let AnimationSettings = null;\r\n\r\nexport const OverrideDefaultAnimationSettings = (_settings) => {\r\n    AnimationSettings = { ...DefaultAnimationSettings, ..._settings };\r\n    return AnimationSettings;\r\n}"]}